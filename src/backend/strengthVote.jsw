/**
 * å¼ºåº¦æ¦œäºŒé€‰ä¸€æŠ•ç¥¨ - åç«¯æœåŠ¡
 * - ä»…å…è®¸å·²å®Œæˆ 10 ä¸ªè¯„åˆ†ä»»åŠ¡çš„ç”¨æˆ·å‚ä¸
 * - ä½œå“æ¥æºï¼šenterContest034ï¼Œæ’é™¤ isDq=true çš„ä½œå“
 * - æœºåˆ¶ï¼šåŒ¹é… -> ç¥¨æ®ç»‘å®š -> Elo æ›´æ–° -> æ¦œå•
 */

import wixData from "wix-data";
import { getUserTaskData } from "backend/ratingTaskManager.jsw";
import { COLLECTIONS } from "backend/constants.js";
import { logError } from "backend/errorHandler.js";

const COLLECTION_MAP = {
  WORKS: COLLECTIONS.ENTER_CONTEST_034,
  SESSIONS: "StrengthVoteSessions",
  STATS: "StrengthVoteStats",
  // LOGS: "StrengthVoteLogs", // å·²ç§»é™¤ï¼šç›´æ¥ä½¿ç”¨ Summary å³å¯
  SUMMARY: "StrengthVoteUserSummary",
};

const REQUIRED_TASKS = 10;
const MAX_VOTES = 80;
const DEFAULT_RATING = 1500;
const MAX_LEADERBOARD_SIZE = 100;
const STATS_QUERY_CHUNK = 50;
const SESSION_TTL_MINUTES = 10;
const CONTESTANT_WEIGHT = 0.2;
// è°ƒè¯•å¼€å…³ï¼šfalse æ—¶è·³è¿‡â€œå®Œæˆä»»åŠ¡ 10 æ¬¡â€çš„é™åˆ¶ï¼ˆä»éœ€ç™»å½•ï¼‰
const ENFORCE_TASK_COMPLETION = true;

/**
 * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦ä¸ºå‚èµ›é€‰æ‰‹ï¼ˆåœ¨ä½œå“åº“ä¸­æœ‰ä½œå“ï¼‰
 */
async function isUserContestant(userId) {
  if (!userId) return false;
  try {
    const result = await wixData
      .query(COLLECTION_MAP.WORKS)
      .eq("_owner", userId)
      .ne("isDq", true)
      .limit(1000)
      .find();
    
    // ğŸ”’ ä¸ fetchActiveWorks ä¿æŒä¸€è‡´ï¼šå¿…é¡»æœ‰æœ‰æ•ˆçš„ sequenceId
    const validWorks = (result.items || []).filter(
      (item) => item && item.sequenceId !== undefined && item.sequenceId !== null
    );
    
    return validWorks.length > 0;
  } catch (error) {
    logError("strengthVote.isUserContestant", error, { userId });
    return false;
  }
}

/**
 * è§„èŒƒåŒ– Wix åª’ä½“ URLï¼Œé€‚é…å›¾ç‰‡/æ–‡ä»¶å­—æ®µçš„å¤šç§æ ¼å¼
 */
function normalizeWixImageUrl(value) {
  if (!value) {
    return "";
  }

  if (typeof value === "object") {
    const candidates = [value.url, value.src, value.fileUrl];
    for (const candidate of candidates) {
      const normalized = normalizeWixImageUrl(candidate);
      if (normalized) {
        return normalized;
      }
    }
    return "";
  }

  if (typeof value !== "string") {
    return "";
  }

  const trimmed = value.trim();
  if (!trimmed) {
    return "";
  }

  if (/^https?:\/\//i.test(trimmed)) {
    return trimmed;
  }

  if (trimmed.startsWith("wix:image://")) {
    const match = trimmed.match(
      /^wix:image:\/\/v1\/([^/#]+)(?:\/[^#]*)?(?:#.*)?$/
    );
    return match ? `https://static.wixstatic.com/media/${match[1]}` : "";
  }

  return trimmed;
}

/**
 * å°è¯•æå–ä½œå“å°é¢
 * ä¼˜å…ˆä½¿ç”¨å·²å­˜åœ¨çš„å°é¢/ç¼©ç•¥å›¾å­—æ®µï¼Œå…œåº•ä¸ºç©ºå­—ç¬¦ä¸²
 */
function pickCoverImage(work = {}) {
  const candidateKeys = [
    "coverImage",
    "cover",
    "thumbnail",
    "å°é¢",
    "trackçš„è¤‡æœ¬",
    "bgçš„è¤‡æœ¬",
    "ä¸Šå‚³æª”æ¡ˆæ¬„",
  ];

  for (const key of candidateKeys) {
    const value = work[key];
    const normalized = normalizeWixImageUrl(value);
    if (normalized) {
      return normalized;
    }
  }

  return "";
}

function getMatchesCount(stats) {
  if (!stats) {
    return 0;
  }
  const wins = Number(stats.wins || 0);
  const losses = Number(stats.losses || 0);
  return wins + losses;
}

function generateSessionId() {
  return `sv_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
}

function calculateKFactor(matches) {
  if (matches < 5) return 40;
  if (matches < 15) return 32;
  return 24;
}

function calculateWinRate(wins = 0, losses = 0) {
  const total = Number(wins || 0) + Number(losses || 0);
  if (total === 0) return 0;
  return Number((Number(wins || 0) / total).toFixed(4));
}

// å·²ç§»é™¤ fetchUserLogsï¼šä¸å†éœ€è¦æŸ¥è¯¢ logs
// Summary åŒ…å«æ‰€æœ‰å¿…è¦ä¿¡æ¯

// å·²ç§»é™¤ buildPersonalEloMapï¼šä¸ªäºº Elo ç›´æ¥åœ¨ Summary ä¸­å¢é‡æ›´æ–°

async function getUserSummary(userId) {
  if (!userId) return null;
  try {
    const result = await wixData
      .query(COLLECTION_MAP.SUMMARY)
      .eq("userId", userId)
      .limit(1)
      .find();
    return result.items?.[0] || null;
  } catch (error) {
    logError("strengthVote.getUserSummary", error, { userId });
    return null;
  }
}

async function saveUserSummary(payload, existingSummary = null) {
  if (!payload || !payload.userId) {
    return null;
  }

  try {
    if (existingSummary?._id) {
      const updated = {
        ...existingSummary,
        ...payload,
        _id: existingSummary._id,
      };
      return await wixData.update(COLLECTION_MAP.SUMMARY, updated);
    }
    return await wixData.insert(COLLECTION_MAP.SUMMARY, payload);
  } catch (error) {
    logError("strengthVote.saveUserSummary", error, { userId: payload.userId });
    try {
      const result = await wixData
        .query(COLLECTION_MAP.SUMMARY)
        .eq("userId", payload.userId)
        .limit(1)
        .find();
      const existing = result.items?.[0];
      if (existing?._id) {
        return await wixData.update(COLLECTION_MAP.SUMMARY, {
          ...existing,
          ...payload,
          _id: existing._id,
        });
      }
    } catch (retryError) {
      logError("strengthVote.saveUserSummary.retry", retryError, {
        userId: payload.userId,
      });
    }
    return payload;
  }
}

// å·²ç§»é™¤ clearUserLogsï¼šä¸å†éœ€è¦æ¸…ç† logs

// å·²ç§»é™¤ clearUserSessionsï¼šæ¯æ¬¡æŠ•ç¥¨åç«‹å³åˆ é™¤ sessionï¼Œæ— éœ€æ‰¹é‡æ¸…ç†

// å·²ç§»é™¤ buildSummaryFromLogsï¼šSummary ç›´æ¥å¢é‡æ›´æ–°ï¼Œæ— éœ€ä» logs é‡å»º

function buildCountMapFromSummary(summary) {
  const countMap = {};
  const winsMap = summary?.winsMap || {};
  const lossesMap = summary?.lossesMap || {};

  Object.keys(winsMap).forEach((key) => {
    const id = Number(key);
    const val = Number(winsMap[key] || 0);
    if (!Number.isFinite(id) || !Number.isFinite(val)) return;
    countMap[id] = (countMap[id] || 0) + val;
  });

  Object.keys(lossesMap).forEach((key) => {
    const id = Number(key);
    const val = Number(lossesMap[key] || 0);
    if (!Number.isFinite(id) || !Number.isFinite(val)) return;
    countMap[id] = (countMap[id] || 0) + val;
  });

  countMap.__pairCounts = summary?.pairCounts || {};
  return countMap;
}

function buildCoverageCountFromSummary(summary) {
  const winsMap = summary?.winsMap || {};
  const lossesMap = summary?.lossesMap || {};
  const keys = new Set([...Object.keys(winsMap), ...Object.keys(lossesMap)]);
  return keys.size;
}

async function updateUserSummaryWithVote(userId, winner, loser) {
  const existingSummary = await getUserSummary(userId);
  const winsMap = { ...(existingSummary?.winsMap || {}) };
  const lossesMap = { ...(existingSummary?.lossesMap || {}) };
  const eloMap = { ...(existingSummary?.eloMap || {}) };
  const pairCounts = { ...(existingSummary?.pairCounts || {}) };

  const winnerKey = String(winner);
  const loserKey = String(loser);

  const winnerWins = Number(winsMap[winnerKey] || 0);
  const winnerLosses = Number(lossesMap[winnerKey] || 0);
  const loserWins = Number(winsMap[loserKey] || 0);
  const loserLosses = Number(lossesMap[loserKey] || 0);

  const winnerRating = Number(eloMap[winnerKey] || DEFAULT_RATING);
  const loserRating = Number(eloMap[loserKey] || DEFAULT_RATING);
  const winnerMatches = winnerWins + winnerLosses;
  const loserMatches = loserWins + loserLosses;

  const expectedWinner = 1 / (1 + 10 ** ((loserRating - winnerRating) / 400));
  const expectedLoser = 1 - expectedWinner;

  const winnerK = calculateKFactor(winnerMatches);
  const loserK = calculateKFactor(loserMatches);

  const winnerDelta = Math.round(winnerK * (1 - expectedWinner));
  const loserDelta = Math.round(loserK * (0 - expectedLoser));

  eloMap[winnerKey] = Math.max(0, winnerRating + winnerDelta);
  eloMap[loserKey] = Math.max(0, loserRating + loserDelta);

  winsMap[winnerKey] = winnerWins + 1;
  lossesMap[loserKey] = loserLosses + 1;

  const pairKey = winner < loser ? `${winner}-${loser}` : `${loser}-${winner}`;
  pairCounts[pairKey] = (pairCounts[pairKey] || 0) + 1;

  const totalVotes = Number(existingSummary?.totalVotes || 0) + 1;

  const payload = {
    userId,
    totalVotes,
    winsMap,
    lossesMap,
    eloMap,
    pairCounts,
    updatedAt: new Date(),
  };

  const saved = await saveUserSummary(payload, existingSummary);

  return {
    summary: saved || payload,
    personalDeltas: {
      winnerDelta,
      loserDelta,
    },
  };
}

async function ensureUserSummaryIfNeeded(userId) {
  if (!userId) {
    return { summary: null, totalVotes: 0 };
  }

  const existingSummary = await getUserSummary(userId);
  if (existingSummary) {
    const summaryVotes = Number(existingSummary.totalVotes || 0);
    return { summary: existingSummary, totalVotes: summaryVotes };
  }

  // Summary ä¸å­˜åœ¨ï¼Œè¯´æ˜æ˜¯æ–°ç”¨æˆ·ï¼Œè¿”å›ç©ºçŠ¶æ€
  return { summary: null, totalVotes: 0 };
}

async function checkEligibility(userId) {
  if (!userId) {
    return {
      eligible: false,
      reason: "notLoggedIn",
      totalCompleted: 0,
      targetCompletion: REQUIRED_TASKS,
    };
  }

  if (!ENFORCE_TASK_COMPLETION) {
    return {
      eligible: true,
      reason: "debugBypass",
      totalCompleted: 0,
      targetCompletion: REQUIRED_TASKS,
    };
  }

  try {
    const taskData = await getUserTaskData(userId);
    const totalCompleted = Number(taskData?.totalCompleted || 0);
    const targetCompletion = Number(
      taskData?.targetCompletion || REQUIRED_TASKS
    );
    const hasCompleted =
      taskData?.hasCompletedTarget || totalCompleted >= targetCompletion;

    if (taskData?.error) {
      return {
        eligible: false,
        reason: taskData?.notSubmitted ? "noSubmission" : "taskDataError",
        message: taskData?.message || "ä»»åŠ¡æ•°æ®å¼‚å¸¸",
        totalCompleted,
        targetCompletion,
      };
    }

    if (!hasCompleted) {
      return {
        eligible: false,
        reason: "insufficientTasks",
        totalCompleted,
        targetCompletion,
      };
    }

    return {
      eligible: true,
      totalCompleted,
      targetCompletion,
    };
  } catch (error) {
    logError("strengthVote.checkEligibility", error);
    return {
      eligible: false,
      reason: "unknown",
      message: error.message,
      totalCompleted: 0,
      targetCompletion: REQUIRED_TASKS,
    };
  }
}

async function fetchActiveWorks() {
  const works = [];
  try {
    let result = await wixData
      .query(COLLECTION_MAP.WORKS)
      .ne("isDq", true)
      .limit(1000)
      .ascending("_createdDate")
      .find();

    works.push(...(result.items || []));

    while (result.hasNext()) {
      result = await result.next();
      works.push(...(result.items || []));
    }
  } catch (error) {
    logError("strengthVote.fetchActiveWorks", error);
  }

  return works.filter(
    (item) => item && item.sequenceId !== undefined && item.sequenceId !== null
  );
}

// // è°ƒè¯•ç‰ˆï¼šä»…å– sequenceId æœ€å¤§çš„ 20 æ¡ï¼Œæ’é™¤ isDq
// async function fetchActiveWorks() {
//   try {
//     const result = await wixData
//       .query(COLLECTION_MAP.WORKS)
//       .ne("isDq", true)
//       .descending("sequenceId")
//       .limit(20)
//       .find();

//     return (result.items || []).filter(
//       (item) => item && item.sequenceId !== undefined && item.sequenceId !== null
//     );
//   } catch (error) {
//     logError("strengthVote.fetchActiveWorks", error);
//     return [];
//   }
// }

async function fetchStatsMap(workNumbers = []) {
  if (!Array.isArray(workNumbers) || workNumbers.length === 0) {
    return {};
  }

  const statsMap = {};
  for (let i = 0; i < workNumbers.length; i += STATS_QUERY_CHUNK) {
    const chunk = workNumbers.slice(i, i + STATS_QUERY_CHUNK);
    try {
      const result = await wixData
        .query(COLLECTION_MAP.STATS)
        .hasSome("workNumber", chunk)
        .limit(1000)
        .find();

      (result.items || []).forEach((item) => {
        const key = Number(item.workNumber);
        statsMap[key] = item;
      });
    } catch (error) {
      logError("strengthVote.fetchStatsMap", error, { chunk });
    }
  }

  return statsMap;
}

async function ensureStats(work, existingStats) {
  if (existingStats) {
    return existingStats;
  }

  const workNumber = Number(work.sequenceId);
  const base = {
    workNumber,
    title: work.firstName || `ä½œå“ #${workNumber}`,
    rating: DEFAULT_RATING,
    wins: 0,
    losses: 0,
    matches: 0,
    coverImage: pickCoverImage(work),
    lastMatchAt: null,
  };

  try {
    const saved = await wixData.insert(COLLECTION_MAP.STATS, base);
    return saved;
  } catch (error) {
    logError("strengthVote.ensureStats.insertFailed", error, {
      workNumber,
    });
    
    // ğŸ”’ é˜²é‡å¤ï¼šæ’å…¥å¤±è´¥å¯èƒ½æ˜¯å› ä¸ºå¹¶å‘è¯·æ±‚å·²ç»åˆ›å»ºäº†è®°å½•ï¼Œå°è¯•æŸ¥è¯¢
    try {
      const result = await wixData
        .query(COLLECTION_MAP.STATS)
        .eq("workNumber", workNumber)
        .limit(1)
        .find();
      
      if (result.items && result.items.length > 0) {
        // æ‰¾åˆ°äº†å·²å­˜åœ¨çš„è®°å½•ï¼Œè¿”å›å®ƒ
        return result.items[0];
      }
    } catch (queryError) {
      logError("strengthVote.ensureStats.queryFailed", queryError, {
        workNumber,
      });
    }
    
    // æŸ¥è¯¢ä¹Ÿå¤±è´¥äº†ï¼Œè¿”å›åŸºç¡€å¯¹è±¡ï¼ˆä¸å¸¦ _idï¼‰
    return base;
  }
}

function pickMatchPair(
  works,
  statsMap,
  userWorkCounts = {},
  personalRatings = {}
) {
  if (!works || works.length < 2) {
    throw new Error("ä½œå“æ•°é‡ä¸è¶³ï¼Œæ— æ³•ç”Ÿæˆå¯¹å†³");
  }

  // 1. æ•°æ®å‡†å¤‡
  const personalCount = (seqId) => Number(userWorkCounts[seqId] || 0);
  const pairCounts = (pairKey) =>
    userWorkCounts?.__pairCounts
      ? Number(userWorkCounts.__pairCounts[pairKey] || 0)
      : 0;

  /**
   * æ ¸å¿ƒï¼šåŠ æƒ Rating é€»è¾‘
   * ä¸ºäº†æé«˜åŒ¹é…æ•ˆç‡ï¼Œåœ¨ç”¨æˆ·å¯¹æŸä¸ªä½œå“äº†è§£è¾ƒå°‘æ—¶ï¼Œå¾®é‡å‚è€ƒå…¨ç«™ Eloã€‚
   * - æ²¡è§è¿‡ (0æ¬¡): 20% å…¨ç«™å‚è€ƒï¼Œè½»å¾®å¼•å¯¼åˆ°åˆé€‚çš„æ®µä½ã€‚
   * - è§è¿‡ 1 æ¬¡: 5% å…¨ç«™å‚è€ƒï¼Œæé€Ÿå›å½’ä¸ªäººå®¡ç¾ã€‚
   * - è§è¿‡ 2 æ¬¡+: 0% å…¨ç«™å‚è€ƒï¼Œå®Œå…¨åŸºäºä¸ªäºº Elo è¿›è¡ŒåŒå±‚åŒ¹é…ã€‚
   */
  const getWeightedRating = (seqId) => {
    const pRating = Number(personalRatings[seqId] || DEFAULT_RATING);
    const gRating = Number(statsMap?.[seqId]?.rating || DEFAULT_RATING);
    const mCount = personalCount(seqId);

    if (mCount === 0) return pRating * 0.8 + gRating * 0.2;
    if (mCount === 1) return pRating * 0.95 + gRating * 0.05;
    return pRating;
  };

  // 2. åŠ¨æ€åˆ†ä½æ®µä½è®¡ç®—ï¼ˆåŸºäºåŠ æƒåçš„ Ratingï¼‰
  const ratingValues = works
    .map((w) => getWeightedRating(w.sequenceId))
    .sort((a, b) => a - b);

  const pickPercentile = (p) => {
    const idx = Math.max(
      0,
      Math.min(
        ratingValues.length - 1,
        Math.floor((ratingValues.length - 1) * p)
      )
    );
    return ratingValues[idx];
  };

  const thresholds = {
    lowMid: pickPercentile(0.2),
    mid: pickPercentile(0.4),
    highMid: pickPercentile(0.6),
    high: pickPercentile(0.8),
  };

  const tiers = ["LOW", "LOW_MID", "MID", "HIGH_MID", "HIGH"];
  const getTier = (r) => {
    if (r >= thresholds.high) return "HIGH";
    if (r >= thresholds.highMid) return "HIGH_MID";
    if (r >= thresholds.mid) return "MID";
    if (r >= thresholds.lowMid) return "LOW_MID";
    return "LOW";
  };

  // 3. é€‰æ‹© Anchor (ä¼˜å…ˆå‡ºåœºæœ€å°‘çš„ä½œå“)
  const sortedByPersonal = [...works].sort((a, b) => {
    const diff = personalCount(a.sequenceId) - personalCount(b.sequenceId);
    if (diff !== 0) return diff;
    // å¦‚æœä¸ªäººå‡ºåœºæ¬¡æ•°ç›¸åŒï¼Œå‚è€ƒå…¨ç«™å‡ºåœºæ¬¡æ•°ï¼Œå¸®åŠ©ç³»ç»Ÿå†·å¯åŠ¨
    const gMatchesA = getMatchesCount(statsMap[a.sequenceId]);
    const gMatchesB = getMatchesCount(statsMap[b.sequenceId]);
    return gMatchesA - gMatchesB;
  });

  // å°è¯•ä»å‡ºåœºæœ€å°‘çš„ä½œå“ä¸­æ‰¾ä¸€ä¸ªâ€œæœ‰æ–°å¯¹æ‰‹å¯é…å¯¹â€çš„ä½œä¸º Anchor
  let anchor = sortedByPersonal[0];
  const anchorLimit = Math.min(sortedByPersonal.length, 10);
  for (let i = 0; i < anchorLimit; i++) {
    const potential = sortedByPersonal[i];
    const pId = Number(potential.sequenceId);
    const hasUnpaired = works.some((w) => {
      if (w.sequenceId === potential.sequenceId) return false;
      const wId = Number(w.sequenceId);
      const key = pId < wId ? `${pId}-${wId}` : `${wId}-${pId}`;
      return pairCounts(key) === 0;
    });
    if (hasUnpaired) {
      anchor = potential;
      break;
    }
  }

  // 4. ç­›é€‰ Candidate (å¯¹æ‰‹)
  let candidates = works.filter((w) => w.sequenceId !== anchor.sequenceId);
  const anchorId = Number(anchor.sequenceId);

  // ğŸ”’ å¼ºåˆ¶éš”ç»ï¼šä¼˜å…ˆé€‰æ‹©ä»æœªé…å¯¹è¿‡çš„ç»„åˆ
  const unpaired = candidates.filter((w) => {
    const wId = Number(w.sequenceId);
    const key = anchorId < wId ? `${anchorId}-${wId}` : `${wId}-${anchorId}`;
    return pairCounts(key) === 0;
  });
  if (unpaired.length > 0) {
    candidates = unpaired;
  }

  // ğŸ”’ åŠ¿å‡åŠ›æ•Œï¼šåœ¨æ®µä½å†…å¯»æ‰¾å¯¹æ‰‹
  const anchorRating = getWeightedRating(anchor.sequenceId);
  const anchorTier = getTier(anchorRating);
  const anchorTierIdx = tiers.indexOf(anchorTier);

  const sameTier = candidates.filter(
    (w) => getTier(getWeightedRating(w.sequenceId)) === anchorTier
  );
  if (sameTier.length > 0) {
    candidates = sameTier;
  } else {
    // é™çº§å¯»æ‰¾ç›¸é‚»æ®µä½
    const neighbors = candidates.filter((w) => {
      const tIdx = tiers.indexOf(getTier(getWeightedRating(w.sequenceId)));
      return Math.abs(tIdx - anchorTierIdx) === 1;
    });
    if (neighbors.length > 0) {
      candidates = neighbors;
    }
  }

  // 5. éšæœºæŠ½å–
  const opponent =
    candidates[Math.floor(Math.random() * Math.max(1, candidates.length))];

  return { workA: anchor, workB: opponent };
}

function buildWorkPayload(work, stats) {
  const wins = Number(stats?.wins || 0);
  const losses = Number(stats?.losses || 0);
  const matches = Number(stats?.matches || wins + losses);

  return {
    workNumber: Number(work.sequenceId),
    title: work.firstName || `ä½œå“ #${work.sequenceId}`,
    description: work["è¼ƒé•·ç­”æ¡ˆæ¬„"] || "",
    coverImage: stats?.coverImage || pickCoverImage(work),
    rating: Number(stats?.rating || DEFAULT_RATING),
    wins,
    losses,
    matches,
    winRate: calculateWinRate(wins, losses),
    lastMatchAt: stats?.lastMatchAt || null,
  };
}

export async function getStrengthVoteStatus(userId) {
  const eligibility = await checkEligibility(userId);
  await ensureUserSummaryIfNeeded(userId);
  return eligibility;
}

export async function requestStrengthComparison(userId) {
  const eligibility = await checkEligibility(userId);
  if (!eligibility.eligible) {
    return {
      success: false,
      code: "notEligible",
      message: "æ‚¨å°šæœªå®Œæˆå¿…è¦çš„è¯„åˆ†ä»»åŠ¡ï¼Œæ— æ³•å‚ä¸æŠ•ç¥¨",
      eligibility,
    };
  }

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.totalVotes >= MAX_VOTES) {
    return {
      success: false,
      code: "voteLimitReached",
      message: "å·²è¾¾åˆ°ç´¯è®¡ä¸Šé™ï¼ˆ" + MAX_VOTES + " æ¬¡ 1v1 æŠ•ç¥¨ï¼‰",
    };
  }

  // ğŸ”’ é˜²åˆ·ç¥¨ï¼šå…ˆæ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æœªä½¿ç”¨çš„ç¥¨æ®
  try {
    const existingSessionResult = await wixData
      .query(COLLECTION_MAP.SESSIONS)
      .eq("userId", userId)
      .eq("used", false)
      .limit(1)
      .find();

    if (existingSessionResult.items && existingSessionResult.items.length > 0) {
      const existingSession = existingSessionResult.items[0];
      const now = new Date();
      
      // æ£€æŸ¥ç¥¨æ®æ˜¯å¦è¿‡æœŸ
      if (existingSession.expiresAt && new Date(existingSession.expiresAt) > now) {
        // ç¥¨æ®æœ‰æ•ˆï¼Œè¿”å›ç°æœ‰çš„ç»„åˆ
        const workNumbers = [Number(existingSession.workA), Number(existingSession.workB)];
        
        const workResult = await wixData
          .query(COLLECTION_MAP.WORKS)
          .hasSome("sequenceId", workNumbers)
          .ne("isDq", true)
          .limit(2)
          .find();

        if (workResult.items && workResult.items.length === 2) {
          const statsMap = await fetchStatsMap(workNumbers);
          const workMap = {};
          workResult.items.forEach((item) => {
            workMap[Number(item.sequenceId)] = item;
          });

          const workA = workMap[existingSession.workA];
          const workB = workMap[existingSession.workB];

          if (workA && workB) {
            return {
              success: true,
              sessionId: existingSession.sessionId,
              expiresAt: existingSession.expiresAt,
              pair: [
                buildWorkPayload(workA, statsMap[workA.sequenceId]),
                buildWorkPayload(workB, statsMap[workB.sequenceId]),
              ],
            };
          }
        }
      }
      
      // å¦‚æœç¥¨æ®è¿‡æœŸæˆ–ä½œå“ä¸å¯ç”¨ï¼Œåˆ é™¤è¿™ä¸ªè¿‡æœŸç¥¨æ®
      try {
        await wixData.remove(COLLECTION_MAP.SESSIONS, existingSession._id);
      } catch (removeError) {
        logError("strengthVote.requestStrengthComparison.removeExpiredSession", removeError, {
          sessionId: existingSession.sessionId,
        });
      }
    }
  } catch (error) {
    logError("strengthVote.requestStrengthComparison.checkExistingSession", error, {
      userId,
    });
    // æŸ¥è¯¢å¤±è´¥ä¸å½±å“åç»­æµç¨‹ï¼Œç»§ç»­ç”Ÿæˆæ–°ç¥¨æ®
  }

  // æ²¡æœ‰æœ‰æ•ˆçš„æœªä½¿ç”¨ç¥¨æ®ï¼Œç”Ÿæˆæ–°çš„
  const allWorks = await fetchActiveWorks();
  // è¿‡æ»¤æ‰å½“å‰ç”¨æˆ·è‡ªå·±æäº¤çš„ä½œå“
  const works = allWorks.filter((item) => item._owner !== userId);

  if (works.length < 2) {
    return {
      success: false,
      code: "noWorks",
      message: "å¯ç”¨ä½œå“ä¸è¶³ï¼Œæ— æ³•åˆ›å»ºå¯¹å†³",
    };
  }

  const workNumbers = works.map((item) => Number(item.sequenceId));
  const statsMap = await fetchStatsMap(workNumbers);

  // ä¸ªäººæŠ•ç¥¨å‚ä¸æ¬¡æ•°æ˜ å°„
  const userWorkCounts = await getUserWorkCounts(userId);
  // ä» Summary è·å–ä¸ªäºº Elo è¯„åˆ†ï¼ˆæ–°ç”¨æˆ·ä¸ºç©ºå¯¹è±¡ï¼‰
  const personalRatings = voteState.summary?.eloMap || {};

  const { workA, workB } = pickMatchPair(
    works,
    statsMap,
    userWorkCounts,
    personalRatings
  );

  const sessionId = generateSessionId();
  const now = new Date();
  const sessionRecord = {
    sessionId,
    userId,
    workA: Number(workA.sequenceId),
    workB: Number(workB.sequenceId),
    createdAt: now,
    expiresAt: new Date(now.getTime() + SESSION_TTL_MINUTES * 60 * 1000),
    used: false,
  };

  try {
    await wixData.insert(COLLECTION_MAP.SESSIONS, sessionRecord);
  } catch (error) {
    logError("strengthVote.requestStrengthComparison.insertSession", error, {
      sessionId,
    });
  }

  return {
    success: true,
    sessionId,
    expiresAt: sessionRecord.expiresAt,
    pair: [
      buildWorkPayload(workA, statsMap[workA.sequenceId]),
      buildWorkPayload(workB, statsMap[workB.sequenceId]),
    ],
  };
}

export async function submitStrengthVote(userId, sessionId, winnerWorkNumber) {
  const eligibility = await checkEligibility(userId);
  if (!eligibility.eligible) {
    return {
      success: false,
      code: "notEligible",
      message: "è¯·å…ˆå®Œæˆ 10 ä¸ªè¯„åˆ†ä»»åŠ¡åå†å‚ä¸æŠ•ç¥¨",
      eligibility,
    };
  }

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.totalVotes >= MAX_VOTES) {
    return {
      success: false,
      code: "voteLimitReached",
      message: "å·²è¾¾åˆ°ç´¯è®¡ä¸Šé™ï¼ˆ" + MAX_VOTES + " æ¬¡ 1v1 æŠ•ç¥¨ï¼‰",
    };
  }

  try {
    const sessionResult = await wixData
      .query(COLLECTION_MAP.SESSIONS)
      .eq("sessionId", sessionId)
      .limit(1)
      .find();

    if (!sessionResult.items || sessionResult.items.length === 0) {
      return {
        success: false,
        code: "invalidSession",
        message: "ç¥¨æ®ä¸å­˜åœ¨æˆ–å·²å¤±æ•ˆ",
      };
    }

    const session = sessionResult.items[0];
    const now = new Date();
    if (session.used) {
      return {
        success: false,
        code: "usedSession",
        message: "è¯¥ç¥¨æ®å·²ä½¿ç”¨ï¼Œè¯·åˆ·æ–°é‡æ–°è·å–å¯¹å†³",
      };
    }

    if (session.expiresAt && new Date(session.expiresAt) < now) {
      return {
        success: false,
        code: "expiredSession",
        message: "ç¥¨æ®å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–å¯¹å†³",
      };
    }

    if (session.userId && session.userId !== userId) {
      return {
        success: false,
        code: "sessionMismatch",
        message: "ç¥¨æ®ä¸å½“å‰è´¦å·ä¸åŒ¹é…",
      };
    }

    const pairNumbers = [Number(session.workA), Number(session.workB)];
    const winner = Number(winnerWorkNumber);

    if (!pairNumbers.includes(winner)) {
      return {
        success: false,
        code: "invalidWinner",
        message: "æäº¤çš„ä½œå“ä¸åœ¨ç¥¨æ®å¯¹å†³ä¸­",
      };
    }

    const loser = pairNumbers.find((num) => num !== winner);

    const workResult = await wixData
      .query(COLLECTION_MAP.WORKS)
      .hasSome("sequenceId", [winner, loser])
      .ne("isDq", true)
      .limit(2)
      .find();

    if (!workResult.items || workResult.items.length < 2) {
      return {
        success: false,
        code: "workUnavailable",
        message: "ä½œå“å·²ä¸‹æ¶æˆ–è¢«æ·˜æ±°ï¼Œæ— æ³•è®¡ç¥¨",
      };
    }

    const workMap = {};
    workResult.items.forEach((item) => {
      workMap[Number(item.sequenceId)] = item;
    });
    const winnerWork = workMap[winner];
    const loserWork = workMap[loser];

    const statsMap = await fetchStatsMap([winner, loser]);
    const winnerStats = await ensureStats(winnerWork, statsMap[winner]);
    const loserStats = await ensureStats(loserWork, statsMap[loser]);

    const winnerRating = Number(winnerStats.rating || DEFAULT_RATING);
    const loserRating = Number(loserStats.rating || DEFAULT_RATING);
    const expectedWinner = 1 / (1 + 10 ** ((loserRating - winnerRating) / 400));
    const expectedLoser = 1 - expectedWinner;

    const winnerMatches = getMatchesCount(winnerStats);
    const loserMatches = getMatchesCount(loserStats);

    const winnerK = calculateKFactor(winnerMatches);
    const loserK = calculateKFactor(loserMatches);

    const rawWinnerDelta = Math.round(winnerK * (1 - expectedWinner));
    const rawLoserDelta = Math.round(loserK * (0 - expectedLoser));

    // ğŸ”’ é€‰æ‰‹æƒé‡ç¼©æ”¾ï¼šå¦‚æœæ˜¯å‚èµ›é€‰æ‰‹ï¼Œå¯¹å…¨ç«™ Elo çš„å½±å“å‡åŠ
    const isContestant = await isUserContestant(userId);
    const weight = isContestant ? CONTESTANT_WEIGHT : 1.0;

    const winnerDelta = Math.round(rawWinnerDelta * weight);
    const loserDelta = Math.round(rawLoserDelta * weight);

    const updatedWinner = {
      ...winnerStats,
      rating: Math.max(0, winnerRating + winnerDelta),
      wins: Number(winnerStats.wins || 0) + 1,
      matches: winnerMatches + 1,
      lastMatchAt: now,
    };

    const updatedLoser = {
      ...loserStats,
      rating: Math.max(0, loserRating + loserDelta),
      losses: Number(loserStats.losses || 0) + 1,
      matches: loserMatches + 1,
      lastMatchAt: now,
    };

    await wixData.update(COLLECTION_MAP.STATS, updatedWinner);
    await wixData.update(COLLECTION_MAP.STATS, updatedLoser);

    // âœ… ç›´æ¥æ›´æ–° Summaryï¼Œæ— éœ€å†™å…¥ Log
    const userSummaryResult = await updateUserSummaryWithVote(
      userId,
      winner,
      loser
    );

    // âœ… æŠ•ç¥¨æˆåŠŸåç«‹å³åˆ é™¤è¯¥ sessionï¼ˆä¼˜åŒ–å­˜å‚¨ï¼‰
    try {
      await wixData.remove(COLLECTION_MAP.SESSIONS, session._id);
    } catch (error) {
      logError("strengthVote.submitStrengthVote.removeSession", error, {
        sessionId,
      });
      // åˆ é™¤å¤±è´¥ä¸å½±å“æŠ•ç¥¨ç»“æœ
    }

    return {
      success: true,
      message: "æŠ•ç¥¨æˆåŠŸï¼Œæ’åå·²æ›´æ–°",
      winner: buildWorkPayload(winnerWork, updatedWinner),
      loser: buildWorkPayload(loserWork, updatedLoser),
      isContestant,
      weight,
      deltas: {
        winnerDelta,
        loserDelta,
        rawWinnerDelta,
        rawLoserDelta,
      },
      personalDeltas: userSummaryResult?.personalDeltas || {
        winnerDelta: 0,
        loserDelta: 0,
      },
    };
  } catch (error) {
    logError("strengthVote.submitStrengthVote", error, {
      sessionId,
      winnerWorkNumber,
    });
    return {
      success: false,
      code: "serverError",
      message: "ä¿å­˜æŠ•ç¥¨å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•",
    };
  }
}

/**
 * ç»Ÿè®¡æ¯ä¸ªä½œå“çš„ W/L ä¸­ï¼Œæœ‰å¤šå°‘æ¥è‡ªåº“ä¸­é€‰æ‰‹çš„æŠ•ç¥¨
 */
async function calculateContestantContribution(workNumbers = []) {
  if (!workNumbers || workNumbers.length === 0) {
    return {};
  }

  const contributionMap = {};
  workNumbers.forEach((num) => {
    contributionMap[num] = {
      contestantWins: 0,
      nonContestantWins: 0,
      contestantLosses: 0,
      nonContestantLosses: 0,
    };
  });

  try {
    // è·å–æ‰€æœ‰ç”¨æˆ·çš„ Summary
    let summaries = [];
    let result = await wixData
      .query(COLLECTION_MAP.SUMMARY)
      .limit(1000)
      .find();
    summaries.push(...(result.items || []));

    while (result.hasNext()) {
      result = await result.next();
      summaries.push(...(result.items || []));
    }

    // éå†æ¯ä¸ªç”¨æˆ·çš„æŠ•ç¥¨è®°å½•
    for (const summary of summaries) {
      if (!summary || !summary.userId) continue;

      // æ£€æŸ¥è¯¥ç”¨æˆ·æ˜¯å¦ä¸ºåº“ä¸­é€‰æ‰‹
      const isContestant = await isUserContestant(summary.userId);

      const winsMap = summary.winsMap || {};
      const lossesMap = summary.lossesMap || {};

      // ç»Ÿè®¡è¯¥ç”¨æˆ·å¯¹æ¯ä¸ªä½œå“çš„æŠ•ç¥¨è´¡çŒ®
      Object.keys(winsMap).forEach((workKey) => {
        const workNum = Number(workKey);
        const wins = Number(winsMap[workKey] || 0);
        if (contributionMap[workNum]) {
          if (isContestant) {
            contributionMap[workNum].contestantWins += wins;
          } else {
            contributionMap[workNum].nonContestantWins += wins;
          }
        }
      });

      Object.keys(lossesMap).forEach((workKey) => {
        const workNum = Number(workKey);
        const losses = Number(lossesMap[workKey] || 0);
        if (contributionMap[workNum]) {
          if (isContestant) {
            contributionMap[workNum].contestantLosses += losses;
          } else {
            contributionMap[workNum].nonContestantLosses += losses;
          }
        }
      });
    }
  } catch (error) {
    logError("strengthVote.calculateContestantContribution", error);
  }

  return contributionMap;
}

export async function getStrengthLeaderboard(limit = 50) {
  const cappedLimit = Math.min(
    limit || MAX_LEADERBOARD_SIZE,
    MAX_LEADERBOARD_SIZE
  );
  const works = await fetchActiveWorks();
  if (works.length === 0) {
    return [];
  }

  const workNumbers = works.map((item) => Number(item.sequenceId));
  const statsMap = await fetchStatsMap(workNumbers);

  // ğŸ”’ ç»Ÿè®¡æ¯ä¸ªä½œå“çš„ W/L ä¸­ï¼Œæœ‰å¤šå°‘æ¥è‡ªåº“ä¸­é€‰æ‰‹
  const contributionMap = await calculateContestantContribution(workNumbers);

  const leaderboard = works.map((work) => {
    const payload = buildWorkPayload(work, statsMap[work.sequenceId]);
    const workNum = Number(work.sequenceId);
    const contribution = contributionMap[workNum] || {
      contestantWins: 0,
      nonContestantWins: 0,
      contestantLosses: 0,
      nonContestantLosses: 0,
    };
    return {
      ...payload,
      contestantWins: contribution.contestantWins,
      nonContestantWins: contribution.nonContestantWins,
      contestantLosses: contribution.contestantLosses,
      nonContestantLosses: contribution.nonContestantLosses,
    };
  });

  leaderboard.sort((a, b) => {
    if (b.rating !== a.rating) {
      return b.rating - a.rating;
    }
    if (b.winRate !== a.winRate) {
      return b.winRate - a.winRate;
    }
    if (b.wins !== a.wins) {
      return b.wins - a.wins;
    }
    return a.workNumber - b.workNumber;
  });

  return leaderboard.slice(0, cappedLimit);
}

/**
 * è·å–å½“å‰ç”¨æˆ·çš„ä½œå“æ¦œå•ï¼ˆä»…åŒ…å«è¯¥ç”¨æˆ·çš„ä½œå“ï¼‰
 */
export async function getStrengthLeaderboardForUser(userId, limit = 50) {
  if (!userId) {
    return [];
  }

  const cappedLimit = Math.min(
    limit || MAX_LEADERBOARD_SIZE,
    MAX_LEADERBOARD_SIZE
  );
  const works = await fetchActiveWorks();
  const userWorks = works.filter(
    (item) => item._owner === userId && item.isDq !== true
  );

  if (userWorks.length === 0) {
    return [];
  }

  const workNumbers = userWorks.map((item) => Number(item.sequenceId));
  const statsMap = await fetchStatsMap(workNumbers);

  const leaderboard = userWorks.map((work) =>
    buildWorkPayload(work, statsMap[work.sequenceId])
  );

  leaderboard.sort((a, b) => {
    if (b.rating !== a.rating) {
      return b.rating - a.rating;
    }
    if (b.winRate !== a.winRate) {
      return b.winRate - a.winRate;
    }
    if (b.wins !== a.wins) {
      return b.wins - a.wins;
    }
    return a.workNumber - b.workNumber;
  });

  return leaderboard.slice(0, cappedLimit);
}

export async function getStrengthUserPersonalRanking(userId, limit = 50) {
  if (!userId) {
    return [];
  }

  const cappedLimit = Math.min(
    limit || MAX_LEADERBOARD_SIZE,
    MAX_LEADERBOARD_SIZE
  );

  const voteState = await ensureUserSummaryIfNeeded(userId);
  let voteCountMap = {};
  let lossCountMap = {};
  let personalEloMap = {};

  if (voteState.summary) {
    voteCountMap = voteState.summary.winsMap || {};
    lossCountMap = voteState.summary.lossesMap || {};
    personalEloMap = voteState.summary.eloMap || {};
  } else {
    // æ–°ç”¨æˆ·æˆ–æ— æŠ•ç¥¨è®°å½•
    return [];
  }

  const voteWorkNumbers = Object.keys(voteCountMap).map((n) => Number(n));
  if (voteWorkNumbers.length === 0) {
    return [];
  }

  const works = await fetchActiveWorks();
  const worksByNumber = {};
  works.forEach((w) => {
    worksByNumber[Number(w.sequenceId)] = w;
  });

  const filteredWorks = voteWorkNumbers
    .map((num) => worksByNumber[num])
    .filter(Boolean);

  if (filteredWorks.length === 0) {
    return [];
  }

  const statsMap = await fetchStatsMap(voteWorkNumbers);
  const ranking = filteredWorks.map((work) => {
    const payload = buildWorkPayload(work, statsMap[work.sequenceId]);
    const userWins = voteCountMap[work.sequenceId] || 0;
    const userLosses = lossCountMap[work.sequenceId] || 0;
    const userTotal = userWins + userLosses;
    const userWinRate =
      userTotal > 0 ? Number((userWins / userTotal).toFixed(4)) : 0;
    const personalElo = personalEloMap[work.sequenceId] || DEFAULT_RATING;

    return {
      ...payload,
      votesByUser: voteCountMap[work.sequenceId] || 0,
      userWins,
      userLosses,
      userWinRate,
      personalElo,
      wins: userWins,
      losses: userLosses,
      winRate: userWinRate,
      rating: personalElo, // ç”¨ä¸ªäººEloæ›¿æ¢å…¨ç«™ratingï¼Œå‰ç«¯å°†æ˜¾ç¤ºä¸ªäººElo
    };
  });

  // ä¼˜å…ˆæŒ‰ä¸ªäººEloæ’åº
  ranking.sort((a, b) => {
    if (b.personalElo !== a.personalElo) {
      return b.personalElo - a.personalElo; // ä¸»æ’åºï¼šä¸ªäººEloï¼ˆä½ å¿ƒä¸­çš„å¼ºåº¦ï¼‰
    }
    if (b.userWinRate !== a.userWinRate) {
      return b.userWinRate - a.userWinRate; // æ¬¡æ’åºï¼šä¸ªäººèƒœç‡
    }
    if (b.userWins !== a.userWins) {
      return b.userWins - a.userWins; // ç¬¬ä¸‰æ’åºï¼šä¸ªäººèƒœåœº
    }
    return a.workNumber - b.workNumber;
  });

  return ranking.slice(0, cappedLimit);
}

export async function getUserVoteCount(userId) {
  if (!userId) {
    return { count: 0, coverage: 0 };
  }

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.summary) {
    return {
      count: Number(voteState.totalVotes || 0),
      coverage: buildCoverageCountFromSummary(voteState.summary),
    };
  }

  // æ–°ç”¨æˆ·ï¼Œæ— æŠ•ç¥¨è®°å½•
  return { count: 0, coverage: 0 };
}

async function getUserWorkCounts(userId) {
  if (!userId) return {};

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.summary) {
    return buildCountMapFromSummary(voteState.summary);
  }

  // æ–°ç”¨æˆ·ï¼Œè¿”å›ç©ºæ˜ å°„
  return {};
}
