/**
 * 强度榜二选一投票 - 后端服务
 * - 仅允许已完成 10 个评分任务的用户参与
 * - 作品来源：enterContest034，排除 isDq=true 的作品
 * - 机制：匹配 -> 票据绑定 -> Elo 更新 -> 榜单
 */

import wixData from "wix-data";
import { getUserTaskData } from "backend/ratingTaskManager.jsw";
import { COLLECTIONS } from "backend/constants.js";
import { logError } from "backend/errorHandler.js";

const COLLECTION_MAP = {
  WORKS: COLLECTIONS.ENTER_CONTEST_034,
  SESSIONS: "StrengthVoteSessions",
  STATS: "StrengthVoteStats",
  // LOGS: "StrengthVoteLogs", // 已移除：直接使用 Summary 即可
  SUMMARY: "StrengthVoteUserSummary",
};

const REQUIRED_TASKS = 10;
const MAX_VOTES = 80;
const DEFAULT_RATING = 1500;
const MATCH_WINDOW = 180;
const EXTENDED_WINDOW = 320;
const SESSION_TTL_MINUTES = 10;
const MAX_LEADERBOARD_SIZE = 100;
const STATS_QUERY_CHUNK = 50;
// 调试开关：false 时跳过“完成任务 10 次”的限制（仍需登录）
const ENFORCE_TASK_COMPLETION = false;

/**
 * 规范化 Wix 媒体 URL，适配图片/文件字段的多种格式
 */
function normalizeWixImageUrl(value) {
  if (!value) {
    return "";
  }

  if (typeof value === "object") {
    const candidates = [value.url, value.src, value.fileUrl];
    for (const candidate of candidates) {
      const normalized = normalizeWixImageUrl(candidate);
      if (normalized) {
        return normalized;
      }
    }
    return "";
  }

  if (typeof value !== "string") {
    return "";
  }

  const trimmed = value.trim();
  if (!trimmed) {
    return "";
  }

  if (/^https?:\/\//i.test(trimmed)) {
    return trimmed;
  }

  if (trimmed.startsWith("wix:image://")) {
    const match = trimmed.match(
      /^wix:image:\/\/v1\/([^/#]+)(?:\/[^#]*)?(?:#.*)?$/
    );
    return match ? `https://static.wixstatic.com/media/${match[1]}` : "";
  }

  return trimmed;
}

/**
 * 尝试提取作品封面
 * 优先使用已存在的封面/缩略图字段，兜底为空字符串
 */
function pickCoverImage(work = {}) {
  const candidateKeys = [
    "coverImage",
    "cover",
    "thumbnail",
    "封面",
    "track的複本",
    "bg的複本",
    "上傳檔案欄",

  ];

  for (const key of candidateKeys) {
    const value = work[key];
    const normalized = normalizeWixImageUrl(value);
    if (normalized) {
      return normalized;
    }
  }

  return "";
}

function getMatchesCount(stats) {
  if (!stats) {
    return 0;
  }
  const wins = Number(stats.wins || 0);
  const losses = Number(stats.losses || 0);
  return wins + losses;
}

function generateSessionId() {
  return `sv_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
}

function calculateKFactor(matches) {
  if (matches < 5) return 40;
  if (matches < 15) return 32;
  return 24;
}

function calculateWinRate(wins = 0, losses = 0) {
  const total = Number(wins || 0) + Number(losses || 0);
  if (total === 0) return 0;
  return Number((Number(wins || 0) / total).toFixed(4));
}

// 已移除 fetchUserLogs：不再需要查询 logs
// Summary 包含所有必要信息

// 已移除 buildPersonalEloMap：个人 Elo 直接在 Summary 中增量更新

async function getUserSummary(userId) {
  if (!userId) return null;
  try {
    const result = await wixData
      .query(COLLECTION_MAP.SUMMARY)
      .eq("userId", userId)
      .limit(1)
      .find();
    return result.items?.[0] || null;
  } catch (error) {
    logError("strengthVote.getUserSummary", error, { userId });
    return null;
  }
}

async function saveUserSummary(payload, existingSummary = null) {
  if (!payload || !payload.userId) {
    return null;
  }

  try {
    if (existingSummary?._id) {
      const updated = { ...existingSummary, ...payload, _id: existingSummary._id };
      return await wixData.update(COLLECTION_MAP.SUMMARY, updated);
    }
    return await wixData.insert(COLLECTION_MAP.SUMMARY, payload);
  } catch (error) {
    logError("strengthVote.saveUserSummary", error, { userId: payload.userId });
    try {
      const result = await wixData
        .query(COLLECTION_MAP.SUMMARY)
        .eq("userId", payload.userId)
        .limit(1)
        .find();
      const existing = result.items?.[0];
      if (existing?._id) {
        return await wixData.update(COLLECTION_MAP.SUMMARY, {
          ...existing,
          ...payload,
          _id: existing._id,
        });
      }
    } catch (retryError) {
      logError("strengthVote.saveUserSummary.retry", retryError, {
        userId: payload.userId,
      });
    }
    return payload;
  }
}

// 已移除 clearUserLogs：不再需要清理 logs

// 已移除 clearUserSessions：每次投票后立即删除 session，无需批量清理

// 已移除 buildSummaryFromLogs：Summary 直接增量更新，无需从 logs 重建

function buildCountMapFromSummary(summary) {
  const countMap = {};
  const winsMap = summary?.winsMap || {};
  const lossesMap = summary?.lossesMap || {};

  Object.keys(winsMap).forEach((key) => {
    const id = Number(key);
    const val = Number(winsMap[key] || 0);
    if (!Number.isFinite(id) || !Number.isFinite(val)) return;
    countMap[id] = (countMap[id] || 0) + val;
  });

  Object.keys(lossesMap).forEach((key) => {
    const id = Number(key);
    const val = Number(lossesMap[key] || 0);
    if (!Number.isFinite(id) || !Number.isFinite(val)) return;
    countMap[id] = (countMap[id] || 0) + val;
  });

  countMap.__pairCounts = summary?.pairCounts || {};
  return countMap;
}

function buildCoverageCountFromSummary(summary) {
  const winsMap = summary?.winsMap || {};
  const lossesMap = summary?.lossesMap || {};
  const keys = new Set([
    ...Object.keys(winsMap),
    ...Object.keys(lossesMap),
  ]);
  return keys.size;
}

async function updateUserSummaryWithVote(userId, winner, loser) {
  const existingSummary = await getUserSummary(userId);
  const winsMap = { ...(existingSummary?.winsMap || {}) };
  const lossesMap = { ...(existingSummary?.lossesMap || {}) };
  const eloMap = { ...(existingSummary?.eloMap || {}) };
  const pairCounts = { ...(existingSummary?.pairCounts || {}) };

  const winnerKey = String(winner);
  const loserKey = String(loser);

  const winnerWins = Number(winsMap[winnerKey] || 0);
  const winnerLosses = Number(lossesMap[winnerKey] || 0);
  const loserWins = Number(winsMap[loserKey] || 0);
  const loserLosses = Number(lossesMap[loserKey] || 0);

  const winnerRating = Number(eloMap[winnerKey] || DEFAULT_RATING);
  const loserRating = Number(eloMap[loserKey] || DEFAULT_RATING);
  const winnerMatches = winnerWins + winnerLosses;
  const loserMatches = loserWins + loserLosses;

  const expectedWinner = 1 / (1 + 10 ** ((loserRating - winnerRating) / 400));
  const expectedLoser = 1 - expectedWinner;

  const winnerK = calculateKFactor(winnerMatches);
  const loserK = calculateKFactor(loserMatches);

  const winnerDelta = Math.round(winnerK * (1 - expectedWinner));
  const loserDelta = Math.round(loserK * (0 - expectedLoser));

  eloMap[winnerKey] = Math.max(0, winnerRating + winnerDelta);
  eloMap[loserKey] = Math.max(0, loserRating + loserDelta);

  winsMap[winnerKey] = winnerWins + 1;
  lossesMap[loserKey] = loserLosses + 1;

  const pairKey = winner < loser ? `${winner}-${loser}` : `${loser}-${winner}`;
  pairCounts[pairKey] = (pairCounts[pairKey] || 0) + 1;

  const totalVotes = Number(existingSummary?.totalVotes || 0) + 1;

  const payload = {
    userId,
    totalVotes,
    winsMap,
    lossesMap,
    eloMap,
    pairCounts,
    updatedAt: new Date(),
  };

  const saved = await saveUserSummary(payload, existingSummary);

  return {
    summary: saved || payload,
    personalDeltas: {
      winnerDelta,
      loserDelta,
    },
  };
}

async function ensureUserSummaryIfNeeded(userId) {
  if (!userId) {
    return { summary: null, totalVotes: 0 };
  }

  const existingSummary = await getUserSummary(userId);
  if (existingSummary) {
    const summaryVotes = Number(existingSummary.totalVotes || 0);
    return { summary: existingSummary, totalVotes: summaryVotes };
  }

  // Summary 不存在，说明是新用户，返回空状态
  return { summary: null, totalVotes: 0 };
}

async function checkEligibility(userId) {
  if (!userId) {
    return {
      eligible: false,
      reason: "notLoggedIn",
      totalCompleted: 0,
      targetCompletion: REQUIRED_TASKS,
    };
  }

  if (!ENFORCE_TASK_COMPLETION) {
    return {
      eligible: true,
      reason: "debugBypass",
      totalCompleted: 0,
      targetCompletion: REQUIRED_TASKS,
    };
  }

  try {
    const taskData = await getUserTaskData(userId);
    const totalCompleted = Number(taskData?.totalCompleted || 0);
    const targetCompletion = Number(
      taskData?.targetCompletion || REQUIRED_TASKS
    );
    const hasCompleted =
      taskData?.hasCompletedTarget || totalCompleted >= targetCompletion;

    if (taskData?.error) {
      return {
        eligible: false,
        reason: taskData?.notSubmitted ? "noSubmission" : "taskDataError",
        message: taskData?.message || "任务数据异常",
        totalCompleted,
        targetCompletion,
      };
    }

    if (!hasCompleted) {
      return {
        eligible: false,
        reason: "insufficientTasks",
        totalCompleted,
        targetCompletion,
      };
    }

    return {
      eligible: true,
      totalCompleted,
      targetCompletion,
    };
  } catch (error) {
    logError("strengthVote.checkEligibility", error);
    return {
      eligible: false,
      reason: "unknown",
      message: error.message,
      totalCompleted: 0,
      targetCompletion: REQUIRED_TASKS,
    };
  }
}



// 正式用法
// async function fetchActiveWorks() {
//   const works = [];
//   try {
//     let result = await wixData
//       .query(COLLECTION_MAP.WORKS)
//       .ne("isDq", true)
//       .limit(1000)
//       .ascending("_createdDate")
//       .find();

//     works.push(...(result.items || []));

//     while (result.hasNext()) {
//       result = await result.next();
//       works.push(...(result.items || []));
//     }
//   } catch (error) {
//     logError("strengthVote.fetchActiveWorks", error);
//   }

//   return works.filter(
//     (item) => item && item.sequenceId !== undefined && item.sequenceId !== null
//   );
// }

// 调试版：仅取 sequenceId 最大的 20 条，排除 isDq
async function fetchActiveWorks() {
  try {
    const result = await wixData
      .query(COLLECTION_MAP.WORKS)
      .ne("isDq", true)
      .descending("sequenceId")
      .limit(20)
      .find();

    return (result.items || []).filter(
      (item) => item && item.sequenceId !== undefined && item.sequenceId !== null
    );
  } catch (error) {
    logError("strengthVote.fetchActiveWorks", error);
    return [];
  }
}







async function fetchStatsMap(workNumbers = []) {
  if (!Array.isArray(workNumbers) || workNumbers.length === 0) {
    return {};
  }

  const statsMap = {};
  for (let i = 0; i < workNumbers.length; i += STATS_QUERY_CHUNK) {
    const chunk = workNumbers.slice(i, i + STATS_QUERY_CHUNK);
    try {
      const result = await wixData
        .query(COLLECTION_MAP.STATS)
        .hasSome("workNumber", chunk)
        .limit(1000)
        .find();

      (result.items || []).forEach((item) => {
        const key = Number(item.workNumber);
        statsMap[key] = item;
      });
    } catch (error) {
      logError("strengthVote.fetchStatsMap", error, { chunk });
    }
  }

  return statsMap;
}

async function ensureStats(work, existingStats) {
  if (existingStats) {
    return existingStats;
  }

  const base = {
    workNumber: Number(work.sequenceId),
    title: work.firstName || `作品 #${work.sequenceId}`,
    rating: DEFAULT_RATING,
    wins: 0,
    losses: 0,
    matches: 0,
    coverImage: pickCoverImage(work),
    lastMatchAt: null,
  };

  try {
    const saved = await wixData.insert(COLLECTION_MAP.STATS, base);
    return saved;
  } catch (error) {
    logError("strengthVote.ensureStats", error, {
      workNumber: work.sequenceId,
    });
    return base;
  }
}

function pickMatchPair(
  works,
  statsMap,
  userWorkCounts = {},
  personalRatings = {}
) {
  if (!works || works.length < 2) {
    throw new Error("作品数量不足，无法生成对决");
  }

  const hasPersonalData =
    userWorkCounts && Object.keys(userWorkCounts).length > 0;
  const hasPersonalRatings =
    personalRatings && Object.keys(personalRatings).length > 0;
  const hasPairPenalty =
    userWorkCounts && userWorkCounts.__pairCounts && Object.keys(userWorkCounts.__pairCounts).length > 0;

  // 计算个人参与次数
  const personalCount = (seqId) => Number(userWorkCounts[seqId] || 0);
  const pairCounts = (pairKey) =>
    hasPairPenalty ? Number(userWorkCounts.__pairCounts[pairKey] || 0) : 0;
  // 五档分段：弱/偏弱/中/偏强/强
  const tiers = ["LOW", "LOW_MID", "MID", "HIGH_MID", "HIGH"];
  const tierIndex = (tier) => tiers.indexOf(tier);
  // 基于 Elo 动态分位段位（20/40/60/80 分位）
  const getRatingValue = (seqId) => {
    if (hasPersonalRatings) {
      return Number(personalRatings[seqId] || DEFAULT_RATING);
    }
    return Number(statsMap?.[seqId]?.rating || DEFAULT_RATING);
  };

  const ratingValues = (hasPersonalRatings
    ? Object.values(personalRatings)
    : works.map((w) => getRatingValue(w.sequenceId))
  )
    .map((v) => Number(v))
    .filter((v) => Number.isFinite(v));
  if (ratingValues.length === 0) {
    ratingValues.push(DEFAULT_RATING);
  }
  ratingValues.sort((a, b) => a - b);
  const pickPercentile = (p) => {
    const idx = Math.max(
      0,
      Math.min(ratingValues.length - 1, Math.floor((ratingValues.length - 1) * p))
    );
    return ratingValues[idx];
  };
  const thresholds = {
    lowMid: pickPercentile(0.2),
    mid: pickPercentile(0.4),
    highMid: pickPercentile(0.6),
    high: pickPercentile(0.8),
  };
  const getTier = (rating) => {
    const r = rating || DEFAULT_RATING;
    if (r >= thresholds.high) return "HIGH";
    if (r >= thresholds.highMid) return "HIGH_MID";
    if (r >= thresholds.mid) return "MID";
    if (r >= thresholds.lowMid) return "LOW_MID";
    return "LOW";
  };

  let anchor;
  let candidates;

  if (hasPersonalData) {
    // 个人偏好：优先让个人参与次数少的作品出场
    const sorted = [...works].sort((a, b) => {
      const diff = personalCount(a.sequenceId) - personalCount(b.sequenceId);
      if (diff === 0) return Math.random() - 0.5;
      return diff;
    });
    anchor = sorted[0];

    candidates = works.filter((w) => w.sequenceId !== anchor.sequenceId);
    // 基于 Elo 动态分位段位（20/40/60/80 分位）
    const anchorRating = getRatingValue(anchor.sequenceId);
    const anchorTier = getTier(anchorRating);
    const anchorTierIdx = tierIndex(anchorTier);

    const sameTier = candidates.filter((w) => {
      const r = getRatingValue(w.sequenceId);
      return getTier(r) === anchorTier;
    });

    const neighborTier = candidates.filter((w) => {
      const r = getRatingValue(w.sequenceId);
      const t = getTier(r);
      return Math.abs(tierIndex(t) - anchorTierIdx) === 1;
    });

    if (sameTier.length > 0) {
      candidates = sameTier;
    } else if (neighborTier.length > 0) {
      candidates = neighborTier;
    }

    // 再按个人出场次数接近筛选（扩大覆盖度）
    const anchorCount = personalCount(anchor.sequenceId);
    const personalClose = candidates.filter(
      (w) => Math.abs(personalCount(w.sequenceId) - anchorCount) <= 2
    );
    if (personalClose.length > 0) {
      candidates = personalClose;
    }

    // 对已出现过的组合施加权重惩罚，减少重复
    if (hasPairPenalty && candidates.length > 1) {
      const anchorId = Number(anchor.sequenceId);
      const weighted = candidates.map((w) => {
        const wId = Number(w.sequenceId);
        const key =
          anchorId < wId ? `${anchorId}-${wId}` : `${wId}-${anchorId}`;
        const times = pairCounts(key);
        const weight = Math.pow(0.3, times); // 指数衰减：0次=100%, 1次=30%, 2次=9%, 3次=3%
        return { w, weight };
      });

      const totalWeight = weighted.reduce((sum, item) => sum + item.weight, 0);
      let rnd = Math.random() * totalWeight;
      for (const item of weighted) {
        rnd -= item.weight;
        if (rnd <= 0) {
          candidates = [item.w];
          break;
        }
      }
    }
  } else {
    // 基于 Elo 动态分位段位（20/40/60/80 分位）
    const shuffled = [...works].sort((a, b) => {
      const matchesA = getMatchesCount(statsMap[a.sequenceId]);
      const matchesB = getMatchesCount(statsMap[b.sequenceId]);
      if (matchesA === matchesB) {
        return Math.random() - 0.5;
      }
      return matchesA - matchesB;
    });

    const anchorIndex = Math.min(
      shuffled.length - 1,
      Math.floor(Math.random() * Math.min(3, shuffled.length))
    );
    anchor = shuffled[anchorIndex];
    const anchorStats = statsMap[anchor.sequenceId];
    const anchorRating = anchorStats?.rating || DEFAULT_RATING;
    const anchorMatches = getMatchesCount(anchorStats);

    candidates = works.filter(
      (item) => item.sequenceId !== anchor.sequenceId
    );

    if (anchorMatches >= 3) {
      const close = candidates.filter((item) => {
        const stats = statsMap[item.sequenceId];
        const rating = stats?.rating || DEFAULT_RATING;
        const matches = getMatchesCount(stats);
        if (matches < 3) {
          return false;
        }
        return Math.abs(rating - anchorRating) <= MATCH_WINDOW;
      });

      if (close.length > 0) {
        candidates = close;
      } else {
        const extended = candidates.filter((item) => {
          const stats = statsMap[item.sequenceId];
          const rating = stats?.rating || DEFAULT_RATING;
          return Math.abs(rating - anchorRating) <= EXTENDED_WINDOW;
        });
        if (extended.length > 0) {
          candidates = extended;
        }
      }
    }
  }

  const opponent =
    candidates[Math.floor(Math.random() * Math.max(1, candidates.length))];

  return { workA: anchor, workB: opponent };
}

function buildWorkPayload(work, stats) {
  const wins = Number(stats?.wins || 0);
  const losses = Number(stats?.losses || 0);
  const matches = Number(stats?.matches || wins + losses);

  return {
    workNumber: Number(work.sequenceId),
    title: work.firstName || `作品 #${work.sequenceId}`,
    description: work["較長答案欄"] || "",
    coverImage: stats?.coverImage || pickCoverImage(work),
    rating: Number(stats?.rating || DEFAULT_RATING),
    wins,
    losses,
    matches,
    winRate: calculateWinRate(wins, losses),
    lastMatchAt: stats?.lastMatchAt || null,
  };
}

export async function getStrengthVoteStatus(userId) {
  const eligibility = await checkEligibility(userId);
  await ensureUserSummaryIfNeeded(userId);
  return eligibility;
}

export async function requestStrengthComparison(userId) {
  const eligibility = await checkEligibility(userId);
  if (!eligibility.eligible) {
    return {
      success: false,
      code: "notEligible",
      message: "您尚未完成必要的评分任务，无法参与投票",
      eligibility,
    };
  }

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.totalVotes >= MAX_VOTES) {
    return {
      success: false,
      code: "voteLimitReached",
      message: "已达到累计上限（" + MAX_VOTES + " 次 1v1 投票）",
    };
  }

  const allWorks = await fetchActiveWorks();
  // 过滤掉当前用户自己提交的作品
  const works = allWorks.filter(item => item._owner !== userId);

  if (works.length < 2) {
    return {
      success: false,
      code: "noWorks",
      message: "可用作品不足，无法创建对决",
    };
  }

  const workNumbers = works.map((item) => Number(item.sequenceId));
  const statsMap = await fetchStatsMap(workNumbers);

  // 个人投票参与次数映射
  const userWorkCounts = await getUserWorkCounts(userId);
  // 从 Summary 获取个人 Elo 评分（新用户为空对象）
  const personalRatings = voteState.summary?.eloMap || {};

  const { workA, workB } = pickMatchPair(
    works,
    statsMap,
    userWorkCounts,
    personalRatings
  );

  const sessionId = generateSessionId();
  const now = new Date();
  const sessionRecord = {
    sessionId,
    userId,
    workA: Number(workA.sequenceId),
    workB: Number(workB.sequenceId),
    createdAt: now,
    expiresAt: new Date(now.getTime() + SESSION_TTL_MINUTES * 60 * 1000),
    used: false,
  };

  try {
    await wixData.insert(COLLECTION_MAP.SESSIONS, sessionRecord);
  } catch (error) {
    logError("strengthVote.requestStrengthComparison.insertSession", error, {
      sessionId,
    });
  }

  return {
    success: true,
    sessionId,
    expiresAt: sessionRecord.expiresAt,
    pair: [
      buildWorkPayload(workA, statsMap[workA.sequenceId]),
      buildWorkPayload(workB, statsMap[workB.sequenceId]),
    ],
  };
}

export async function submitStrengthVote(userId, sessionId, winnerWorkNumber) {
  const eligibility = await checkEligibility(userId);
  if (!eligibility.eligible) {
    return {
      success: false,
      code: "notEligible",
      message: "请先完成 10 个评分任务后再参与投票",
      eligibility,
    };
  }

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.totalVotes >= MAX_VOTES) {
    return {
      success: false,
      code: "voteLimitReached",
      message: "已达到累计上限（" + MAX_VOTES + " 次 1v1 投票）",
    };
  }

  try {
    const sessionResult = await wixData
      .query(COLLECTION_MAP.SESSIONS)
      .eq("sessionId", sessionId)
      .limit(1)
      .find();

    if (!sessionResult.items || sessionResult.items.length === 0) {
      return {
        success: false,
        code: "invalidSession",
        message: "票据不存在或已失效",
      };
    }

    const session = sessionResult.items[0];
    const now = new Date();
    if (session.used) {
      return {
        success: false,
        code: "usedSession",
        message: "该票据已使用，请刷新重新获取对决",
      };
    }

    if (session.expiresAt && new Date(session.expiresAt) < now) {
      return {
        success: false,
        code: "expiredSession",
        message: "票据已过期，请重新获取对决",
      };
    }

    if (session.userId && session.userId !== userId) {
      return {
        success: false,
        code: "sessionMismatch",
        message: "票据与当前账号不匹配",
      };
    }

    const pairNumbers = [Number(session.workA), Number(session.workB)];
    const winner = Number(winnerWorkNumber);

    if (!pairNumbers.includes(winner)) {
      return {
        success: false,
        code: "invalidWinner",
        message: "提交的作品不在票据对决中",
      };
    }

    const loser = pairNumbers.find((num) => num !== winner);

    const workResult = await wixData
      .query(COLLECTION_MAP.WORKS)
      .hasSome("sequenceId", [winner, loser])
      .ne("isDq", true)
      .limit(2)
      .find();

    if (!workResult.items || workResult.items.length < 2) {
      return {
        success: false,
        code: "workUnavailable",
        message: "作品已下架或被淘汰，无法计票",
      };
    }

    const workMap = {};
    workResult.items.forEach((item) => {
      workMap[Number(item.sequenceId)] = item;
    });
    const winnerWork = workMap[winner];
    const loserWork = workMap[loser];

    const statsMap = await fetchStatsMap([winner, loser]);
    const winnerStats = await ensureStats(winnerWork, statsMap[winner]);
    const loserStats = await ensureStats(loserWork, statsMap[loser]);

    const winnerRating = Number(winnerStats.rating || DEFAULT_RATING);
    const loserRating = Number(loserStats.rating || DEFAULT_RATING);
    const expectedWinner = 1 / (1 + 10 ** ((loserRating - winnerRating) / 400));
    const expectedLoser = 1 - expectedWinner;

    const winnerMatches = getMatchesCount(winnerStats);
    const loserMatches = getMatchesCount(loserStats);

    const winnerK = calculateKFactor(winnerMatches);
    const loserK = calculateKFactor(loserMatches);

    const winnerDelta = Math.round(winnerK * (1 - expectedWinner));
    const loserDelta = Math.round(loserK * (0 - expectedLoser));

    const updatedWinner = {
      ...winnerStats,
      rating: Math.max(0, winnerRating + winnerDelta),
      wins: Number(winnerStats.wins || 0) + 1,
      matches: winnerMatches + 1,
      lastMatchAt: now,
    };

    const updatedLoser = {
      ...loserStats,
      rating: Math.max(0, loserRating + loserDelta),
      losses: Number(loserStats.losses || 0) + 1,
      matches: loserMatches + 1,
      lastMatchAt: now,
    };

    await wixData.update(COLLECTION_MAP.STATS, updatedWinner);
    await wixData.update(COLLECTION_MAP.STATS, updatedLoser);

    // ✅ 直接更新 Summary，无需写入 Log
    const userSummaryResult = await updateUserSummaryWithVote(userId, winner, loser);

    // ✅ 投票成功后立即删除该 session（优化存储）
    try {
      await wixData.remove(COLLECTION_MAP.SESSIONS, session._id);
    } catch (error) {
      logError("strengthVote.submitStrengthVote.removeSession", error, { sessionId });
      // 删除失败不影响投票结果
    }

    return {
      success: true,
      message: "投票成功，排名已更新",
      winner: buildWorkPayload(winnerWork, updatedWinner),
      loser: buildWorkPayload(loserWork, updatedLoser),
      deltas: {
        winnerDelta,
        loserDelta,
      },
      personalDeltas: userSummaryResult?.personalDeltas || {
        winnerDelta: 0,
        loserDelta: 0,
      },
    };
  } catch (error) {
    logError("strengthVote.submitStrengthVote", error, {
      sessionId,
      winnerWorkNumber,
    });
    return {
      success: false,
      code: "serverError",
      message: "保存投票失败，请稍后重试",
    };
  }
}

export async function getStrengthLeaderboard(limit = 50) {
  const cappedLimit = Math.min(limit || MAX_LEADERBOARD_SIZE, MAX_LEADERBOARD_SIZE);
  const works = await fetchActiveWorks();
  if (works.length === 0) {
    return [];
  }

  const workNumbers = works.map((item) => Number(item.sequenceId));
  const statsMap = await fetchStatsMap(workNumbers);

  const leaderboard = works.map((work) =>
    buildWorkPayload(work, statsMap[work.sequenceId])
  );

  leaderboard.sort((a, b) => {
    if (b.rating !== a.rating) {
      return b.rating - a.rating;
    }
    if (b.winRate !== a.winRate) {
      return b.winRate - a.winRate;
    }
    if (b.wins !== a.wins) {
      return b.wins - a.wins;
    }
    return a.workNumber - b.workNumber;
  });

  return leaderboard.slice(0, cappedLimit);
}

/**
 * 获取当前用户的作品榜单（仅包含该用户的作品）
 */
export async function getStrengthLeaderboardForUser(userId, limit = 50) {
  if (!userId) {
    return [];
  }

  const cappedLimit = Math.min(limit || MAX_LEADERBOARD_SIZE, MAX_LEADERBOARD_SIZE);
  const works = await fetchActiveWorks();
  const userWorks = works.filter(
    (item) => item._owner === userId && item.isDq !== true
  );

  if (userWorks.length === 0) {
    return [];
  }

  const workNumbers = userWorks.map((item) => Number(item.sequenceId));
  const statsMap = await fetchStatsMap(workNumbers);

  const leaderboard = userWorks.map((work) =>
    buildWorkPayload(work, statsMap[work.sequenceId])
  );

  leaderboard.sort((a, b) => {
    if (b.rating !== a.rating) {
      return b.rating - a.rating;
    }
    if (b.winRate !== a.winRate) {
      return b.winRate - a.winRate;
    }
    if (b.wins !== a.wins) {
      return b.wins - a.wins;
    }
    return a.workNumber - b.workNumber;
  });

  return leaderboard.slice(0, cappedLimit);
}

export async function getStrengthUserPersonalRanking(userId, limit = 50) {
  if (!userId) {
    return [];
  }

  const cappedLimit = Math.min(limit || MAX_LEADERBOARD_SIZE, MAX_LEADERBOARD_SIZE);

  const voteState = await ensureUserSummaryIfNeeded(userId);
  let voteCountMap = {};
  let lossCountMap = {};
  let personalEloMap = {};

  if (voteState.summary) {
    voteCountMap = voteState.summary.winsMap || {};
    lossCountMap = voteState.summary.lossesMap || {};
    personalEloMap = voteState.summary.eloMap || {};
  } else {
    // 新用户或无投票记录
    return [];
  }

  const voteWorkNumbers = Object.keys(voteCountMap).map((n) => Number(n));
  if (voteWorkNumbers.length === 0) {
    return [];
  }

  const works = await fetchActiveWorks();
  const worksByNumber = {};
  works.forEach((w) => {
    worksByNumber[Number(w.sequenceId)] = w;
  });

  const filteredWorks = voteWorkNumbers
    .map((num) => worksByNumber[num])
    .filter(Boolean);

  if (filteredWorks.length === 0) {
    return [];
  }

  const statsMap = await fetchStatsMap(voteWorkNumbers);
  const ranking = filteredWorks.map((work) => {
    const payload = buildWorkPayload(work, statsMap[work.sequenceId]);
    const userWins = voteCountMap[work.sequenceId] || 0;
    const userLosses = lossCountMap[work.sequenceId] || 0;
    const userTotal = userWins + userLosses;
    const userWinRate =
      userTotal > 0 ? Number((userWins / userTotal).toFixed(4)) : 0;
    const personalElo = personalEloMap[work.sequenceId] || DEFAULT_RATING;
    
    return {
      ...payload,
      votesByUser: voteCountMap[work.sequenceId] || 0,
      userWins,
      userLosses,
      userWinRate,
      personalElo,
      wins: userWins,
      losses: userLosses,
      winRate: userWinRate,
      rating: personalElo, // 用个人Elo替换全站rating，前端将显示个人Elo
    };
  });

  // 优先按个人Elo排序
  ranking.sort((a, b) => {
    if (b.personalElo !== a.personalElo) {
      return b.personalElo - a.personalElo; // 主排序：个人Elo（你心中的强度）
    }
    if (b.userWinRate !== a.userWinRate) {
      return b.userWinRate - a.userWinRate; // 次排序：个人胜率
    }
    if (b.userWins !== a.userWins) {
      return b.userWins - a.userWins; // 第三排序：个人胜场
    }
    return a.workNumber - b.workNumber;
  });

  return ranking.slice(0, cappedLimit);
}

export async function getUserVoteCount(userId) {
  if (!userId) {
    return { count: 0, coverage: 0 };
  }

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.summary) {
    return {
      count: Number(voteState.totalVotes || 0),
      coverage: buildCoverageCountFromSummary(voteState.summary),
    };
  }

  // 新用户，无投票记录
  return { count: 0, coverage: 0 };
}

async function getUserWorkCounts(userId) {
  if (!userId) return {};

  const voteState = await ensureUserSummaryIfNeeded(userId);
  if (voteState.summary) {
    return buildCountMapFromSummary(voteState.summary);
  }

  // 新用户，返回空映射
  return {};
}











