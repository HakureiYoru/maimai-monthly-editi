/**
 * 评分任务管理系统 - 后端核心算法
 * 
 * 功能：
 * 1. 基于冷门权重的任务分配
 * 2. 单任务推送机制
 * 3. 自动同步用户评分记录
 */

import wixData from 'wix-data';

const COLLECTIONS = {
  USER_TASKS: 'UserRatingTasks',
  COMMENTS: 'BOFcomment',
  WORKS: 'enterContest034',
  REGISTRATIONS: 'jobApplication089'
};

const TARGET_RATING_COUNT = 20; // 目标评分数
const TARGET_USER_COMPLETION = 10; // 用户目标完成数
const TASK_REFRESH_HOURS = 1/30; // 任务刷新间隔（小时），1/30小时=2分钟（调试用）

/**
 * 获取用户任务数据（主入口）
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 任务数据
 */
export async function getUserTaskData(userId) {
  try {
    // 1. 获取或创建用户任务记录
    let taskRecord = await getUserTaskRecord(userId);
    
    // 2. 检查是否需要刷新任务（基于时间）
    const needsRefresh = shouldRefreshTasks(taskRecord);
    if (needsRefresh) {
      console.log(`用户 ${userId} 任务已超时，将刷新任务列表`);
      // 清空当前任务，强制重新生成
      taskRecord.currentTasks = [];
      taskRecord.lastRefreshTime = new Date();
    }
    
    // 3. 生成当前任务列表（最多3条）
    const currentTasks = await generateUserTasks(userId, taskRecord, 3);
    
    // 4. 更新任务列表和刷新时间到数据库
    if (currentTasks.length > 0 || needsRefresh) {
      taskRecord.currentTasks = currentTasks;
      if (needsRefresh || !taskRecord.lastRefreshTime) {
        taskRecord.lastRefreshTime = new Date();
      }
      await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
    }

    // 5. 获取用户所有评分记录，计算自主评论的作品
    const allUserRatings = await getUserCompletedRatings(userId);
    const freeRatings = allUserRatings.filter(workNum => 
      !taskRecord.completedTasks.includes(workNum)
    );

    return {
      currentTasks: currentTasks,
      completedTasks: taskRecord.completedTasks.sort((a, b) => b - a),
      freeRatings: freeRatings.sort((a, b) => b - a),
      totalCompleted: taskRecord.totalCompleted,
      targetCompletion: TARGET_USER_COMPLETION,
      lastRefreshTime: taskRecord.lastRefreshTime,
      nextRefreshTime: getNextRefreshTime(taskRecord.lastRefreshTime)
    };
    
  } catch (error) {
    console.error('获取用户任务数据失败:', error);
    throw error;
  }
}

/**
 * 生成用户任务列表（最多 limit 条）
 * @param {string} userId
 * @param {object} taskRecord
 * @param {number} limit
 * @returns {Promise<Array<{workNumber:number, weight:number, currentRatings:number}>>}
 */
async function generateUserTasks(userId, taskRecord, limit = 3) {
  try {
    const completedWorks = taskRecord.completedTasks || [];
    const userOwnWork = await getUserOwnWork(userId);
    
    // 获取用户所有已经评论过的作品（包括自评和其他评论）
    const userRatedWorks = await getUserCompletedRatings(userId);

    // 查询所有作品，排除被淘汰的作品
    const allWorksResult = await wixData
      .query(COLLECTIONS.WORKS)
      .ne('isDq', true)
      .limit(1000)
      .find();

    const candidateWorks = [];
    for (const work of allWorksResult.items) {
      // 排除条件：
      // 1. 已在完成任务列表中
      // 2. 是用户自己的作品
      // 3. 用户已经评论过的作品
      if (completedWorks.includes(work.sequenceId) || 
          work.sequenceId === userOwnWork ||
          userRatedWorks.includes(work.sequenceId)) {
        continue;
      }
      
      const coldnessWeight = calculateColdnessWeight(work);
      if (coldnessWeight <= 0) continue;
      const validRatingCount = await getWorkValidRatingCount(work.sequenceId);
      candidateWorks.push({
        workNumber: work.sequenceId,
        weight: coldnessWeight,
        currentRatings: validRatingCount,
        submissionDate: work._createdDate
      });
    }

    if (candidateWorks.length === 0) return [];
    candidateWorks.sort((a, b) => b.weight - a.weight);
    
    // 返回可用的任务数量，不强制凑齐 limit 个
    return candidateWorks.slice(0, Math.min(limit, candidateWorks.length));
  } catch (e) {
    console.error('生成用户任务失败:', e);
    return [];
  }
}

/**
 * 检查作品是否在用户的任务列表中
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 检查结果
 */
export async function checkIfWorkInTaskList(userId, workNumber) {
  try {
    const taskRecord = await getUserTaskRecord(userId);
    
    console.log(`[检查] 作品 #${workNumber}, 已完成: [${taskRecord.completedTasks.join(', ')}]`);
    
    // 检查是否在已完成列表中
    if (taskRecord.completedTasks.includes(workNumber)) {
      console.log(`[检查] ✓ 作品 #${workNumber} 在已完成列表中`);
      return {
        inTaskList: true,
        alreadyCompleted: true
      };
    }
    
    // 检查是否在当前任务列表中（3条任务）
    const currentTasksList = taskRecord.currentTasks || [];
    const taskNums = currentTasksList.map(t => t.workNumber);
    console.log(`[检查] 当前任务列表: [${taskNums.join(', ')}]`);
    
    const inCurrentTasks = currentTasksList.some(t => t.workNumber === workNumber);
    console.log(`[检查] ${inCurrentTasks ? '✓' : '✗'} 作品 #${workNumber} ${inCurrentTasks ? '在' : '不在'}任务列表中`);
    
    return {
      inTaskList: inCurrentTasks,
      alreadyCompleted: false
    };
    
  } catch (error) {
    console.error('检查任务列表失败:', error);
    return {
      inTaskList: false,
      alreadyCompleted: false
    };
  }
}

/**
 * 标记任务完成
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 完成结果
 */
export async function markTaskCompleted(userId, workNumber) {
  try {
    console.log(`\n========== 标记任务: 用户 ${userId}, 作品 #${workNumber} ==========`);
    
    const taskRecord = await getUserTaskRecord(userId);
    console.log(`[标记] 当前已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);
    
    // 检查这个作品是否在任务列表中
    const taskCheck = await checkIfWorkInTaskList(userId, workNumber);
    console.log(`[标记] 检查结果: inTaskList=${taskCheck.inTaskList}, alreadyCompleted=${taskCheck.alreadyCompleted}`);
    
    // 如果已经完成过，直接返回
    if (taskCheck.alreadyCompleted) {
      console.log(`[标记] 作品 #${workNumber} 已在完成列表中，跳过`);
      return {
        success: true,
        taskCompleted: false,
        isInTaskList: true,
        alreadyCompleted: true,
        completedCount: taskRecord.totalCompleted
      };
    }
    
    // 只有在任务列表中的作品才计入完成
    let taskCompleted = false;
    if (taskCheck.inTaskList) {
      console.log(`[标记] ✓ 作品 #${workNumber} 在任务列表中，添加到完成列表`);
      
      // 添加到完成列表
      taskRecord.completedTasks.push(workNumber);
      taskRecord.totalCompleted = taskRecord.completedTasks.length;
      taskCompleted = true;
      
      console.log(`[标记] 更新后已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);
      
      await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
      console.log(`[标记] 数据库已更新`);
    } else {
      console.log(`[标记] ✗ 作品 #${workNumber} 不在任务列表中，不计入进度`);
    }
    
    console.log(`========== 标记任务完成 ==========\n`);
    
    return {
      success: true,
      taskCompleted: taskCompleted,
      isInTaskList: taskCheck.inTaskList,
      alreadyCompleted: false,
      completedCount: taskRecord.totalCompleted
    };
    
  } catch (error) {
    console.error('标记任务完成失败:', error);
    throw error;
  }
}

/**
 * 为用户分配下一个任务（已废弃，改用 generateUserTasks）
 * 保留此函数以兼容同步任务
 */
async function assignNextTask(userId, taskRecord) {
  const tasks = await generateUserTasks(userId, taskRecord, 1);
  return tasks && tasks.length > 0 ? tasks[0] : null;
}

/**
 * 计算作品的冷门权重（0-100）
 * 权重越高表示越冷门，越需要关注
 * 
 * @param {Object} work - 作品对象
 * @returns {number} 冷门权重
 */
function calculateColdnessWeight(work) {
  const daysSinceSubmission = getDaysSinceSubmission(work);
  const currentRatings = work.currentRatingCount || 0;
  
  // 已达标，权重为0
  if (currentRatings >= TARGET_RATING_COUNT) {
    return 0;
  }
  
  // 计算期望评分数（基于时间的线性模型）
  let expectedRatings = 0;
  if (daysSinceSubmission <= 7) {
    expectedRatings = Math.floor(daysSinceSubmission * 1.43); // 7天达到10个
  } else if (daysSinceSubmission <= 30) {
    expectedRatings = 10 + Math.floor((daysSinceSubmission - 7) * 0.43); // 30天达到20个
  } else {
    expectedRatings = TARGET_RATING_COUNT;
  }
  
  // 计算评分缺口
  const deficit = Math.max(0, expectedRatings - currentRatings);
  
  // 基础权重：缺口比例（降低最大值从60到45）
  const deficitRatio = expectedRatings > 0 ? deficit / expectedRatings : 0;
  const baseWeight = deficitRatio * 45; // 最大45分（从60降低）
  
  // 时间紧迫度加成（降低加成幅度）
  let urgencyBonus = 0;
  if (daysSinceSubmission > 7 && currentRatings < 10) {
    urgencyBonus = 12; // 从20降低到12
  }
  if (daysSinceSubmission > 14 && currentRatings < 15) {
    urgencyBonus = 18; // 从30降低到18
  }
  if (daysSinceSubmission > 21 && currentRatings < 18) {
    urgencyBonus = 25; // 从40降低到25
  }
  
  // 总权重（现在最大约70分，不容易达到100）
  const totalWeight = Math.min(100, baseWeight + urgencyBonus);
  
  return Math.round(totalWeight);
}

/**
 * 检查任务是否需要刷新
 * @param {Object} taskRecord - 任务记录
 * @returns {boolean} 是否需要刷新
 */
function shouldRefreshTasks(taskRecord) {
  // 如果没有刷新时间记录，需要刷新
  if (!taskRecord.lastRefreshTime) {
    return true;
  }
  
  // 计算距离上次刷新的小时数
  const now = new Date();
  const lastRefresh = new Date(taskRecord.lastRefreshTime);
  const hoursSinceRefresh = (now - lastRefresh) / (1000 * 60 * 60);
  
  // 如果超过刷新间隔，需要刷新
  return hoursSinceRefresh >= TASK_REFRESH_HOURS;
}

/**
 * 计算下次刷新时间
 * @param {Date} lastRefreshTime - 上次刷新时间
 * @returns {Date} 下次刷新时间
 */
function getNextRefreshTime(lastRefreshTime) {
  if (!lastRefreshTime) {
    return new Date();
  }
  
  const nextRefresh = new Date(lastRefreshTime);
  nextRefresh.setHours(nextRefresh.getHours() + TASK_REFRESH_HOURS);
  return nextRefresh;
}

/**
 * 获取用户任务记录
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 任务记录
 */
async function getUserTaskRecord(userId) {
  try {
    const results = await wixData
      .query(COLLECTIONS.USER_TASKS)
      .eq('userId', userId)
      .find();
    
    if (results.items.length === 0) {
      // 创建新记录
      const newRecord = {
        userId: userId,
        currentTasks: [],  // 改为任务列表（最多3条）
        completedTasks: [],
        totalCompleted: 0,
        lastRefreshTime: new Date() // 初始化刷新时间
      };
      
      const inserted = await wixData.insert(COLLECTIONS.USER_TASKS, newRecord);
      return inserted;
    }
    
    return results.items[0];
    
  } catch (error) {
    console.error('获取用户任务记录失败:', error);
    throw error;
  }
}

/**
 * 获取用户已完成的评分作品列表
 * @param {string} userId - 用户ID
 * @returns {Promise<number[]>} 作品序号数组
 */
async function getUserCompletedRatings(userId) {
  try {
    let allComments = [];
    let hasMore = true;
    let skipCount = 0;
    const limit = 100;
    
    while (hasMore) {
      const results = await wixData
        .query(COLLECTIONS.COMMENTS)
        .eq('_owner', userId)
        .isEmpty('replyTo')
        .skip(skipCount)
        .limit(limit)
        .find();
      
      allComments = allComments.concat(results.items);
      skipCount += results.items.length;
      hasMore = results.items.length === limit;
    }
    
    // 提取作品序号（去重）
    const workNumbers = [...new Set(allComments.map(c => c.workNumber))];
    return workNumbers;
    
  } catch (error) {
    console.error('获取用户评分记录失败:', error);
    return [];
  }
}

/**
 * 获取作品信息
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object|null>} 作品信息
 */
async function getWorkInfo(workNumber) {
  try {
    const results = await wixData
      .query(COLLECTIONS.WORKS)
      .eq('sequenceId', workNumber)
      .find();
    
    if (results.items.length > 0) {
      return results.items[0];
    }
    return null;
    
  } catch (error) {
    console.error('获取作品信息失败:', error);
    return null;
  }
}

/**
 * 获取作品的有效评分数（排除作者自评）
 * @param {number} workNumber - 作品序号
 * @returns {Promise<number>} 有效评分数
 */
async function getWorkValidRatingCount(workNumber) {
  try {
    // 获取所有评论
    const comments = await wixData
      .query(COLLECTIONS.COMMENTS)
      .eq('workNumber', workNumber)
      .isEmpty('replyTo')
      .find();
    
    // 获取作品所有者
    const work = await getWorkInfo(workNumber);
    if (!work) return 0;
    
    const workOwnerId = work._owner;
    
    // 排除作者自评
    const validRatings = comments.items.filter(c => c._owner !== workOwnerId);
    
    return validRatings.length;
    
  } catch (error) {
    console.error('获取作品评分数失败:', error);
    return 0;
  }
}

/**
 * 获取用户自己的作品序号
 * @param {string} userId - 用户ID
 * @returns {Promise<number|null>} 作品序号
 */
async function getUserOwnWork(userId) {
  try {
    const results = await wixData
      .query(COLLECTIONS.WORKS)
      .eq('_owner', userId)
      .find();
    
    return results.items.length > 0 ? results.items[0].sequenceId : null;
    
  } catch (error) {
    console.error('获取用户作品失败:', error);
    return null;
  }
}

/**
 * 计算作品提交天数
 * @param {Object} work - 作品对象
 * @returns {number} 天数
 */
function getDaysSinceSubmission(work) {
  const now = new Date();
  const submissionDate = new Date(work._createdDate);
  const diffTime = Math.abs(now - submissionDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
}

/**
 * 同步所有用户的任务状态（定时任务）
 * 每日运行一次 - 主要用于为没有任务的用户分配任务
 */
export async function syncAllUserRatings() {
  try {
    console.log('开始同步所有用户任务状态...');
    
    // 获取所有已报名用户
    const registeredUsers = await getRegisteredUsers();
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const user of registeredUsers) {
      try {
        const taskRecord = await getUserTaskRecord(user.userId);
        
        // 只负责为没有任务的用户分配任务
        // 不再同步所有评分记录，因为只有任务列表中的作品才应该计入
        if ((!taskRecord.currentTask || taskRecord.currentTask.status === 'completed') &&
            taskRecord.totalCompleted < TARGET_USER_COMPLETION) {
          await assignNextTask(user.userId, taskRecord);
        }
        
        successCount++;
        
      } catch (error) {
        console.error(`同步用户 ${user.userId} 失败:`, error);
        errorCount++;
      }
    }
    
    console.log(`同步完成: 成功 ${successCount}, 失败 ${errorCount}`);
    
    return {
      success: true,
      successCount,
      errorCount
    };
    
  } catch (error) {
    console.error('同步任务状态失败:', error);
    throw error;
  }
}

/**
 * 获取所有已报名的参赛用户
 * @returns {Promise<Array>} 用户列表
 */
async function getRegisteredUsers() {
  try {
    let allRegistrations = [];
    let hasMore = true;
    let skipCount = 0;
    const limit = 100;
    
    while (hasMore) {
      const results = await wixData
        .query(COLLECTIONS.REGISTRATIONS)
        .skip(skipCount)
        .limit(limit)
        .find();
      
      allRegistrations = allRegistrations.concat(results.items);
      skipCount += results.items.length;
      hasMore = results.items.length === limit;
    }
    
    // 提取用户ID（去重）
    const userIds = [...new Set(allRegistrations.map(reg => reg._owner).filter(id => id))];
    
    return userIds.map(userId => ({ userId }));
    
  } catch (error) {
    console.error('获取参赛用户失败:', error);
    return [];
  }
}

/**
 * 更新所有作品的评分计数（定时任务）
 * 每日运行一次
 */
export async function updateAllWorkRatingCounts() {
  try {
    console.log('开始更新所有作品评分计数...');
    
    const allWorks = await wixData
      .query(COLLECTIONS.WORKS)
      .limit(1000)
      .find();
    
    let updateCount = 0;
    
    for (const work of allWorks.items) {
      const validRatingCount = await getWorkValidRatingCount(work.sequenceId);
      
      if (work.currentRatingCount !== validRatingCount) {
        work.currentRatingCount = validRatingCount;
        await wixData.update(COLLECTIONS.WORKS, work);
        updateCount++;
      }
    }
    
    console.log(`更新完成: ${updateCount} 个作品`);
    
    return {
      success: true,
      updateCount
    };
    
  } catch (error) {
    console.error('更新作品评分计数失败:', error);
    throw error;
  }
}

/**
 * 获取系统统计信息（管理用）
 */
export async function getSystemStats() {
  try {
    // 获取所有任务记录
    const allTasks = await wixData
      .query(COLLECTIONS.USER_TASKS)
      .limit(1000)
      .find();
    
    // 获取所有作品
    const allWorks = await wixData
      .query(COLLECTIONS.WORKS)
      .ne('isDq', true)
      .limit(1000)
      .find();
    
    // 统计用户完成情况
    const completionStats = {
      completed20: 0,
      completed10to19: 0,
      completed1to9: 0,
      completed0: 0
    };
    
    allTasks.items.forEach(task => {
      const count = task.totalCompleted || 0;
      if (count >= 20) completionStats.completed20++;
      else if (count >= 10) completionStats.completed10to19++;
      else if (count >= 1) completionStats.completed1to9++;
      else completionStats.completed0++;
    });
    
    // 统计作品评分情况
    const workStats = {
      reached20: 0,
      reached10to19: 0,
      reached1to9: 0,
      reached0: 0
    };
    
    for (const work of allWorks.items) {
      const count = work.currentRatingCount || 0;
      if (count >= 20) workStats.reached20++;
      else if (count >= 10) workStats.reached10to19++;
      else if (count >= 1) workStats.reached1to9++;
      else workStats.reached0++;
    }
    
    return {
      totalUsers: allTasks.items.length,
      totalWorks: allWorks.items.length,
      userCompletion: completionStats,
      workRatings: workStats,
      timestamp: new Date()
    };
    
  } catch (error) {
    console.error('获取系统统计失败:', error);
    throw error;
  }
}


