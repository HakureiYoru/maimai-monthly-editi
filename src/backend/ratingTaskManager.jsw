/**
 * 评分任务管理系统 - 后端核心算法
 *
 * 功能：
 * 1. 基于冷门权重的任务分配
 * 2. 单任务推送机制
 * 3. 自动同步用户评分记录
 *
 * 重要说明：
 * - 作品评论数实时从 BOFcomment 数据集统计（排除作者自评）
 * - enterContest034.currentRatingCount 字段已废弃不再使用
 * - 避免使用缓存字段导致数据不同步问题
 */

import wixData from "wix-data";

const COLLECTIONS = {
  USER_TASKS: "UserRatingTasks",
  COMMENTS: "BOFcomment",
  WORKS: "enterContest034",
  REGISTRATIONS: "jobApplication089",
};

const TARGET_RATING_COUNT = 15; // 目标评分数（压缩到15评）
const TARGET_USER_COMPLETION = 10; // 用户目标完成数
const TASK_REFRESH_HOURS = 8; // 任务刷新间隔（小时），1/30小时=2分钟（调试用） 1=1小时

// 高权重评分系统配置
const TARGET_HIGH_LOW_RATIO = 0.333; // 目标高低权重比例 1:3 = 0.333
const RATIO_TOLERANCE = 0.15; // 容忍度 ±5% → 0.20到0.30可接受
const BALANCE_FACTOR_ADJUSTMENT = 0.1; // 权重调整幅度 30%

// 任务拥挤度控制（避免同一作品被过多人同时领取）
const MIN_PARALLEL_TASKS_PER_WORK = 3; // 每个作品并发基准（收紧）
const PARALLEL_TASKS_BUFFER = 1; // 缺口附加并发（收紧）
const PARALLEL_TASKS_EXTRA_TOLERANCE = 1; // 软上限后仅多放1个
const TASK_SATURATION_PENALTY_STEP = 0.25; // 超限降权更陡
const TASK_SATURATION_FALLBACK_PENALTY = 0.5; // 只有饱和任务可选时的降权系数
const MAX_PARALLEL_TASKS_PER_WORK = 6; // 并发硬封顶

// 用户权重缓存
let userQualityCache = {};

/**
 * 获取所有主评论（分页，避免 1000 条上限）
 * @param {Object} options - 过滤选项
 * @param {number} [options.workNumber] - 可选，按作品编号筛选
 * @param {string} [options.ownerId] - 可选，按作者ID筛选
 * @returns {Promise<Array>} 主评论数组
 */
async function fetchAllMainComments(options = {}) {
  const { workNumber, ownerId } = options;
  const pageSize = 100; // 按 100 条分页拉取，确保大数据量完整获取
  let query = wixData.query(COLLECTIONS.COMMENTS).isEmpty("replyTo");

  if (workNumber !== undefined && workNumber !== null) {
    query = query.eq("workNumber", workNumber);
  }

  if (ownerId) {
    query = query.eq("_owner", ownerId);
  }

  let results = await query.limit(pageSize).find();
  const allComments = [...results.items];

  while (results.hasNext()) {
    results = await results.next();
    allComments.push(...results.items);
  }

  return allComments;
}

/**
 * 获取用户任务数据（主入口）
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 任务数据
 */
export async function getUserTaskData(userId) {
  try {
    // 1. 【新增】检查用户是否已提交作品
    const hasSubmittedWork = await checkUserHasSubmittedWork(userId);
    if (!hasSubmittedWork) {
      // 用户未提交作品，返回特定错误状态
      return {
        error: true,
        notSubmitted: true,
        message: "您还未提交作品，请先提交作品后才能接收评分任务",
        currentTasks: [],
        completedTasks: [],
        freeRatings: [],
        totalCompleted: 0,
        targetCompletion: TARGET_USER_COMPLETION,
        isHighQuality: false,
        ownWorks: [],
        hasCompletedTarget: false,
      };
    }

    // 2. 获取或创建用户任务记录
    let taskRecord = await getUserTaskRecord(userId, {
      requireSubmittedWork: true,
    });

    // 3. 检查是否需要刷新任务（基于时间）
    const needsRefresh = shouldRefreshTasks(taskRecord);
    
    // 4. 【修复】只有在需要刷新或任务列表为空时，才重新生成任务
    let currentTasks = taskRecord.currentTasks || [];
    
    if (needsRefresh || currentTasks.length === 0) {
      // console.log(`用户 ${userId} 任务需要刷新或为空，重新生成任务列表`);
      
      // 生成新的任务列表（最多3条）
      currentTasks = await generateUserTasks(userId, taskRecord, 3);
      
      // 更新任务列表和刷新时间到数据库
      taskRecord.currentTasks = currentTasks;
      taskRecord.lastRefreshTime = new Date();
      await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
    } else {
      // console.log(`用户 ${userId} 任务未到刷新时间，使用缓存的任务列表`);
    }

    // 5. 获取用户所有评分记录，计算自主评论的作品
    const allUserRatings = await getUserCompletedRatings(userId);
    const freeRatings = allUserRatings.filter(
      (workNum) => !taskRecord.completedTasks.includes(workNum)
    );

    // 6. 获取用户是否是高权重用户
    const isHighQuality = await isUserHighQuality(userId);

    // 7. 获取用户自己的作品编号（用于前端显示）
    const userOwnWorks = await getUserOwnWorks(userId);

    // 8. 判断用户是否已完成任务目标
    const hasCompletedTarget =
      taskRecord.totalCompleted >= TARGET_USER_COMPLETION;

    return {
      currentTasks: currentTasks,
      completedTasks: taskRecord.completedTasks.sort((a, b) => b - a),
      freeRatings: freeRatings.sort((a, b) => b - a),
      totalCompleted: taskRecord.totalCompleted,
      targetCompletion: TARGET_USER_COMPLETION,
      lastRefreshTime: taskRecord.lastRefreshTime,
      nextRefreshTime: getNextRefreshTime(taskRecord.lastRefreshTime),
      isHighQuality: isHighQuality, // 用户身份标识
      ownWorks: userOwnWorks, // 用户自己的作品列表
      hasCompletedTarget: hasCompletedTarget, // 是否已完成目标
    };
  } catch (error) {
    // console.error('获取用户任务数据失败:', error);
    throw error;
  }
}

/**
 * 生成用户任务列表（最多 limit 条）- 性能优化版
 * @param {string} userId
 * @param {object} taskRecord
 * @param {number} limit
 * @returns {Promise<Array<{workNumber:number, weight:number, currentRatings:number}>>}
 */
async function generateUserTasks(userId, taskRecord, limit = 3) {
  try {
    // console.log(`\n========== 生成用户任务: ${userId} ==========`);
    const startTime = Date.now();

    const completedWorks = taskRecord.completedTasks || [];
    const userOwnWorks = await getUserOwnWorks(userId); // 获取用户所有作品

    // 获取用户所有已经评论过的作品（包括自评和其他评论）
    const userRatedWorks = await getUserCompletedRatings(userId);
    // 当前有哪些作品被其他用户持有，用于避免任务集中在同一作品
    const activeTaskCounts = await getCurrentTaskAssignmentCounts(userId);

    // console.log(`[任务分配] 排除条件 - 已完成:${completedWorks.length}个, 自己作品:${userOwnWorks.length}个, 已评论:${userRatedWorks.length}个`);

    // 查询所有作品，排除被淘汰的作品
    const allWorksResult = await wixData
      .query(COLLECTIONS.WORKS)
      .ne("isDq", true)
      .limit(1000)
      .find();

    // console.log(`[任务分配] 查询到${allWorksResult.items.length}个未淘汰作品`);

    // 【性能优化】批量预加载所有评分数据，避免N+1查询问题
    const allRatingsData = await getAllWorksWeightedRatingData();
    const { workRatings, workOwnerMap, userQualityMap } = allRatingsData;

    // 获取当前用户的权重类型（修复：变量名改为userIsHighQuality避免与函数名冲突）
    const userIsHighQuality = await isUserHighQuality(userId);
    // console.log(`[任务分配] 用户类型: ${userIsHighQuality ? 'Qualified（高权重）' : '普通（低权重）'}`);

    const candidateWorks = [];
    const saturatedCandidates = []; // 记录因并发过高被跳过的作品，必要时兜底使用
    let excludedCount = 0;
    let zeroWeightCount = 0;

    for (const work of allWorksResult.items) {
      // 排除条件：
      // 1. 已在完成任务列表中
      // 2. 是用户自己的作品（支持多个作品）
      // 3. 用户已经评论过的作品
      if (
        completedWorks.includes(work.sequenceId) ||
        userOwnWorks.includes(work.sequenceId) ||
        userRatedWorks.includes(work.sequenceId)
      ) {
        excludedCount++;
        continue;
      }

      // 【优化】从预加载的数据中获取评分信息，而不是单独查询
      const ratingData = workRatings[work.sequenceId] || {
        numRatings: 0,
        highWeightCount: 0,
        lowWeightCount: 0,
      };

      const validRatingCount = ratingData.numRatings;
      work.currentRatingCount = validRatingCount;

      // 【优化】直接计算权重，不再需要额外查询
      const coldnessWeight = calculateColdnessWeightOptimized(
        work,
        validRatingCount,
        ratingData.highWeightCount,
        ratingData.lowWeightCount,
        userIsHighQuality
      );

      if (coldnessWeight <= 0) {
        zeroWeightCount++;
        continue;
      }

       // 根据当前被持有的数量做拥挤度控制，降低重复推送
      const currentAssignments = activeTaskCounts[work.sequenceId] || 0;
      const remainingNeeded = Math.max(0, TARGET_RATING_COUNT - validRatingCount);

      // 收紧并发：以缺口为基准，带小缓冲，整体封顶
      const baseSoftCap = Math.max(
        MIN_PARALLEL_TASKS_PER_WORK,
        remainingNeeded + PARALLEL_TASKS_BUFFER
      );
      const softAssignmentCap = Math.min(
        MAX_PARALLEL_TASKS_PER_WORK,
        baseSoftCap + (remainingNeeded <= 2 ? 1 : 0) // 尾盘额外给1个名额
      );

      let hardAssignmentCap = Math.min(
        MAX_PARALLEL_TASKS_PER_WORK,
        softAssignmentCap + PARALLEL_TASKS_EXTRA_TOLERANCE
      );

      // 确保硬上限至少比软上限高1
      if (hardAssignmentCap <= softAssignmentCap) {
        hardAssignmentCap = Math.min(
          MAX_PARALLEL_TASKS_PER_WORK,
          softAssignmentCap + 1
        );
      }

      // 超过硬上限：直接跳过（避免“太多人已经拥有”）
      if (currentAssignments >= hardAssignmentCap) {
        saturatedCandidates.push({
          workNumber: work.sequenceId,
          weight: coldnessWeight,
          currentRatings: validRatingCount,
          submissionDate: work._createdDate,
        });
        continue;
      }

      // 超过软上限：按并发数阶梯折减权重，优先把任务让给空缺作品
      let adjustedWeight = coldnessWeight;
      if (currentAssignments > softAssignmentCap) {
        const penaltySteps = currentAssignments - softAssignmentCap;
        const penaltyFactor = Math.max(
          0.1,
          1 - penaltySteps * TASK_SATURATION_PENALTY_STEP
        );
        adjustedWeight = Math.max(
          1,
          Math.round(coldnessWeight * penaltyFactor)
        );
      }

      candidateWorks.push({
        workNumber: work.sequenceId,
        weight: adjustedWeight,
        currentRatings: validRatingCount,
        submissionDate: work._createdDate,
      });
    }

    // 去掉饱和兜底，避免“过多人推到同一个任务”的回流

    // console.log(`[任务分配] 候选作品统计 - 总数:${allWorksResult.items.length}, 排除:${excludedCount}, 权重为0:${zeroWeightCount}, 可分配:${candidateWorks.length}`);

    if (candidateWorks.length === 0) {
      // console.log(`[任务分配] ⚠️ 无可分配作品，返回空列表`);
      // console.log(`[任务分配] 排除原因详情:`);
      // console.log(`  - 已完成任务: ${completedWorks.join(', ') || '无'}`);
      // console.log(`  - 自己的作品: ${userOwnWorks.join(', ') || '无'}`);
      // console.log(`  - 已评论过的: ${userRatedWorks.length}个`);
      // console.log(`========== 任务生成完成，耗时: ${Date.now() - startTime}ms ==========\n`);
      return [];
    }

    // 【优化】权重近似时随机化排序，减少用户间任务重合
    // 当两个作品权重相差在20%以内时，随机决定它们的顺序
    candidateWorks.sort((a, b) => {
      const weightDiff = Math.abs(a.weight - b.weight);
      const avgWeight = (a.weight + b.weight) / 2;
      const diffPercentage = avgWeight > 0 ? weightDiff / avgWeight : 0;

      // 如果权重差异小于20%，随机排序
      if (diffPercentage < 0.20) {
        return Math.random() - 0.5; // 随机返回正负值
      }

      // 否则按权重降序排序
      return b.weight - a.weight;
    });

    // 记录前10个权重最高的作品（用于调试）
    const top10 = candidateWorks.slice(0, 10);
    // console.log(`[任务分配] ⭐ 权重TOP10作品 (个性化权重):`);
    // top10.forEach((w, i) => {
    //   const ratingInfo = workRatings[w.workNumber] || {};
    //   console.log(`  ${i + 1}. #${w.workNumber} 权重:${w.weight} | 评分:${w.currentRatings}/15 | 高低:${ratingInfo.highWeightCount || 0}:${ratingInfo.lowWeightCount || 0}`);
    // });

    // 返回可用的任务数量，不强制凑齐 limit 个
    const selectedTasks = candidateWorks.slice(
      0,
      Math.min(limit, candidateWorks.length)
    );
    // console.log(`[任务分配] ✅ 最终分配${selectedTasks.length}个任务:`, selectedTasks.map(t => `#${t.workNumber}(${t.weight})`).join(', '));
    // console.log(`========== 任务生成完成，耗时: ${Date.now() - startTime}ms ==========\n`);

    return selectedTasks;
  } catch (e) {
    console.error("生成用户任务失败:", e);
    return [];
  }
}

/**
 * 计算基础冷门权重（不含均衡因子）
 * @param {Object} work - 作品对象
 * @param {number} currentRatings - 当前评分数
 * @returns {number} 基础权重
 */
function calculateBaseColdnessWeight(work, currentRatings) {
  const daysSinceSubmission = getDaysSinceSubmission(work);

  // 已达标，权重为0
  if (currentRatings >= TARGET_RATING_COUNT) {
    return 0;
  }

  // 计算期望评分数（15天达到15评分的三段式模型）
  let expectedRatings = 0;
  if (daysSinceSubmission <= 5) {
    // 早期：约1评分/天，5天≈5评
    expectedRatings = Math.floor(daysSinceSubmission * 1.0);
  } else if (daysSinceSubmission <= 10) {
    // 中期：约1评分/天，10天≈10评
    expectedRatings = 5 + Math.floor((daysSinceSubmission - 5) * 1.0);
  } else if (daysSinceSubmission <= 15) {
    // 后期：约1评分/天，15天达到15评
    expectedRatings = 10 + Math.floor((daysSinceSubmission - 10) * 1.0);
  } else {
    // 超过15天，期望达标
    expectedRatings = TARGET_RATING_COUNT;
  }

  // 计算评分缺口（按目标15评做分母，避免前期少量评分直接归零）
  const baselineExpected = Math.max(expectedRatings, TARGET_RATING_COUNT);
  const deficit = Math.max(0, baselineExpected - currentRatings);
  const deficitRatio = baselineExpected > 0 ? deficit / baselineExpected : 0;
  const baseWeight = deficitRatio * 60;

  // 时间紧迫度加成（15天达标，按缺口阶梯提升，使用Math.max取最大值）
  let urgencyBonus = 0;
  if (daysSinceSubmission >= 2 && currentRatings < 2) {
    urgencyBonus = Math.max(urgencyBonus, 5); // 2天：早期冷启动1
  }
  if (daysSinceSubmission >= 3 && currentRatings < 3) {
    urgencyBonus = Math.max(urgencyBonus, 10); // 3天：早期冷启动2
  }
  if (daysSinceSubmission >= 5 && currentRatings < 5) {
    urgencyBonus = Math.max(urgencyBonus, 15); // 5天：早期关注
  }
  if (daysSinceSubmission >= 6 && currentRatings < 6) {
    urgencyBonus = Math.max(urgencyBonus, 20); // 6天：中期关注1
  }
  if (daysSinceSubmission >= 8 && currentRatings < 8) {
    urgencyBonus = Math.max(urgencyBonus, 25); // 8天：中期关注2
  }
  if (daysSinceSubmission >= 10 && currentRatings < 10) {
    urgencyBonus = Math.max(urgencyBonus, 25); // 10天：中期紧急
  }
  // if (daysSinceSubmission >= 11 && currentRatings < 11) {
  //   urgencyBonus = Math.max(urgencyBonus, 35); // 11天：后期紧急1
  // }
  // if (daysSinceSubmission >= 13 && currentRatings < 13) {
  //   urgencyBonus = Math.max(urgencyBonus, 35); // 13天：后期紧急2
  // }
  // if (daysSinceSubmission >= 14 && currentRatings < 14) {
  //   urgencyBonus = Math.max(urgencyBonus, 35); // 14天：即将超期
  // }
  // if (daysSinceSubmission >= 15 && currentRatings < 15) {
  //   urgencyBonus = Math.max(urgencyBonus, 35); // 15天：超期最高优先级
  // }

  return Math.round(baseWeight + urgencyBonus);
}

/**
 * 计算作品的冷门权重（优化版，使用预加载数据）
 * @param {Object} work - 作品对象
 * @param {number} validRatingCount - 有效评分数
 * @param {number} highWeightCount - 高权重评分数
 * @param {number} lowWeightCount - 低权重评分数
 * @param {boolean} isUserHighQuality - 用户是否是高权重
 * @returns {number} 冷门权重
 */
function calculateColdnessWeightOptimized(
  work,
  validRatingCount,
  highWeightCount,
  lowWeightCount,
  isUserHighQuality
) {
  // 先计算基础权重
  let totalWeight = calculateBaseColdnessWeight(work, validRatingCount);

  // 如果基础权重为0，直接返回
  if (totalWeight === 0) {
    return 0;
  }

  // 应用均衡因子（评分>=1时）
  if (validRatingCount >= 1) {
    const balanceFactor = calculateBalanceFactor(
      highWeightCount,
      lowWeightCount,
      isUserHighQuality
    );
    totalWeight = totalWeight * balanceFactor;
  }

  // 返回真实计算值，不设上限
  return Math.round(totalWeight);
}

/**
 * 检查作品是否在用户的任务列表中
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 检查结果
 */
export async function checkIfWorkInTaskList(userId, workNumber) {
  try {
    const taskRecord = await getUserTaskRecord(userId, {
      createIfMissing: false,
      requireSubmittedWork: true,
    });

    if (!taskRecord) {
      return {
        inTaskList: false,
        alreadyCompleted: false,
      };
    }

    // console.log(`[检查] 作品 #${workNumber}, 已完成: [${taskRecord.completedTasks.join(', ')}]`);

    // 检查是否在已完成列表中
    if (taskRecord.completedTasks.includes(workNumber)) {
      // console.log(`[检查] ✓ 作品 #${workNumber} 在已完成列表中`);
      return {
        inTaskList: true,
        alreadyCompleted: true,
      };
    }

    // 检查是否在当前任务列表中（3条任务）
    const currentTasksList = taskRecord.currentTasks || [];
    const taskNums = currentTasksList.map((t) => t.workNumber);
    // console.log(`[检查] 当前任务列表: [${taskNums.join(', ')}]`);

    const inCurrentTasks = currentTasksList.some(
      (t) => t.workNumber === workNumber
    );
    // console.log(`[检查] ${inCurrentTasks ? '✓' : '✗'} 作品 #${workNumber} ${inCurrentTasks ? '在' : '不在'}任务列表中`);

    return {
      inTaskList: inCurrentTasks,
      alreadyCompleted: false,
    };
  } catch (error) {
    // console.error('检查任务列表失败:', error);
    return {
      inTaskList: false,
      alreadyCompleted: false,
    };
  }
}

/**
 * 标记任务完成
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 完成结果
 */
export async function markTaskCompleted(userId, workNumber) {
  try {
    // console.log(`\n========== 标记任务: 用户 ${userId}, 作品 #${workNumber} ==========`);

    const taskRecord = await getUserTaskRecord(userId, {
      requireSubmittedWork: true,
    });

    if (!taskRecord) {
      return {
        success: false,
        taskCompleted: false,
        isInTaskList: false,
        alreadyCompleted: false,
        completedCount: 0,
        hasCompletedTarget: false,
        message: "用户未提交作品或无任务记录，未创建空记录",
      };
    }
    // console.log(`[标记] 当前已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);

    // 检查用户是否已完成任务目标
    const hasCompletedTarget =
      taskRecord.totalCompleted >= TARGET_USER_COMPLETION;
    // console.log(`[标记] 用户是否已完成目标: ${hasCompletedTarget} (${taskRecord.totalCompleted}/${TARGET_USER_COMPLETION})`);

    // 检查这个作品是否在任务列表中
    const taskCheck = await checkIfWorkInTaskList(userId, workNumber);
    // console.log(`[标记] 检查结果: inTaskList=${taskCheck.inTaskList}, alreadyCompleted=${taskCheck.alreadyCompleted}`);

    // 如果已经完成过，直接返回
    if (taskCheck.alreadyCompleted) {
      // console.log(`[标记] 作品 #${workNumber} 已在完成列表中，跳过`);
      return {
        success: true,
        taskCompleted: false,
        isInTaskList: true,
        alreadyCompleted: true,
        completedCount: taskRecord.totalCompleted,
        hasCompletedTarget: hasCompletedTarget,
      };
    }

    // 如果用户已完成目标，不再计入任务指标
    if (hasCompletedTarget) {
      // console.log(`[标记] 用户已完成目标，作品 #${workNumber} 不计入任务进度`);
      return {
        success: true,
        taskCompleted: false,
        isInTaskList: taskCheck.inTaskList,
        alreadyCompleted: false,
        completedCount: taskRecord.totalCompleted,
        hasCompletedTarget: true,
        isColdWork: taskCheck.inTaskList, // 标记为冷门作品（在任务列表中但不计入进度）
      };
    }

    // 只有在任务列表中且未完成目标的作品才计入完成
    let taskCompleted = false;
    if (taskCheck.inTaskList) {
      // console.log(`[标记] ✓ 作品 #${workNumber} 在任务列表中，添加到完成列表`);

      // 添加到完成列表
      taskRecord.completedTasks.push(workNumber);
      taskRecord.totalCompleted = taskRecord.completedTasks.length;
      taskCompleted = true;

      // console.log(`[标记] 更新后已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);

      await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
      // console.log(`[标记] 数据库已更新`);
    } else {
      // console.log(`[标记] ✗ 作品 #${workNumber} 不在任务列表中，不计入进度`);
    }

    // console.log(`========== 标记任务完成 ==========\n`);

    return {
      success: true,
      taskCompleted: taskCompleted,
      isInTaskList: taskCheck.inTaskList,
      alreadyCompleted: false,
      completedCount: taskRecord.totalCompleted,
      hasCompletedTarget: false,
    };
  } catch (error) {
    // console.error('标记任务完成失败:', error);
    throw error;
  }
}

/**
 * 取消任务完成状态（删除评论时调用）
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 取消结果
 */
export async function unmarkTaskCompleted(userId, workNumber) {
  try {
    // console.log(`\n========== 取消任务完成: 用户 ${userId}, 作品 #${workNumber} ==========`);

    const taskRecord = await getUserTaskRecord(userId, {
      requireSubmittedWork: true,
      createIfMissing: false,
    });

    if (!taskRecord) {
      return {
        success: false,
        wasInCompletedList: false,
        message: "用户未提交作品或无任务记录，未创建空记录",
      };
    }
    // console.log(`[取消] 当前已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);

    // 检查作品是否在已完成列表中
    const wasCompleted = taskRecord.completedTasks.includes(workNumber);

    if (!wasCompleted) {
      // console.log(`[取消] 作品 #${workNumber} 不在已完成列表中，无需处理`);
      return {
        success: true,
        wasInCompletedList: false,
        message: "作品不在已完成列表中",
      };
    }

    // 从已完成列表中移除
    taskRecord.completedTasks = taskRecord.completedTasks.filter(
      (num) => num !== workNumber
    );
    taskRecord.totalCompleted = taskRecord.completedTasks.length;

    // console.log(`[取消] 更新后已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);

    await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
    // console.log(`[取消] 数据库已更新`);
    // console.log(`========== 取消任务完成 ==========\n`);

    return {
      success: true,
      wasInCompletedList: true,
      newCompletedCount: taskRecord.totalCompleted,
      message: "任务完成状态已取消",
    };
  } catch (error) {
    console.error("取消任务完成失败:", error);
    return {
      success: false,
      wasInCompletedList: false,
      message: "取消失败: " + error.message,
    };
  }
}

/**
 * 【新增】检查用户是否已提交作品到 enterContest034
 * @param {string} userId - 用户ID
 * @returns {Promise<boolean>} 是否已提交作品
 */
async function checkUserHasSubmittedWork(userId) {
  try {
    const result = await wixData
      .query(COLLECTIONS.WORKS)
      .eq("_owner", userId)
      .find();

    // 只要有任何一个作品（无论是否被淘汰），就算已提交
    return result.items.length > 0;
  } catch (error) {
    console.error("检查用户作品提交状态失败:", error);
    return false; // 出错时默认返回 false，安全起见
  }
}

/**
 * 检查用户是否是高权重用户
 * @param {string} userId - 用户ID
 * @returns {Promise<boolean>} 是否是高权重用户
 */
async function isUserHighQuality(userId) {
  // 检查缓存
  if (userId in userQualityCache) {
    return userQualityCache[userId];
  }

  try {
    const result = await wixData
      .query(COLLECTIONS.REGISTRATIONS)
      .eq("_owner", userId)
      .find();

    const isHighQuality =
      result.items.length > 0 && result.items[0].isHighQuality === true;
    userQualityCache[userId] = isHighQuality;
    return isHighQuality;
  } catch (error) {
    // console.error('检查用户权重失败:', error);
    userQualityCache[userId] = false;
    return false;
  }
}

/**
 * 批量获取所有作品的加权评分数据（性能优化版）
 * 一次性查询所有数据，避免重复API调用
 * @returns {Promise<Object>} { workRatings: {workNumber: ratingData}, userQualityMap: {userId: boolean}, workOwnerMap, workDQMap, commentCountMap }
 */
export async function getAllWorksWeightedRatingData() {
  try {
    // 1. 一次性查询所有主评论（包括自评）和作品，使用分页避免 1000 条限制
    const [allComments, allWorks] = await Promise.all([
      fetchAllMainComments(),
      wixData.query(COLLECTIONS.WORKS).limit(1000).find(),
    ]);

    // 3. 建立作品所有者和淘汰状态映射
    const workOwnerMap = {};
    const workDQMap = {};
    allWorks.items.forEach((work) => {
      workOwnerMap[work.sequenceId] = work._owner;
      workDQMap[work.sequenceId] = work.isDq === true;
    });

    // 4. 获取所有评论者的用户权重
    const allUserIds = [...new Set(allComments.map((c) => c._owner))];
    const userQualityMap = await batchCheckUserQuality(allUserIds);

    // 5. 按作品分组评论
    const workComments = {};
    allComments.forEach((comment) => {
      if (!workComments[comment.workNumber]) {
        workComments[comment.workNumber] = [];
      }
      workComments[comment.workNumber].push(comment);
    });

    // 6. 计算每个作品的评分数据
    const workRatings = {};
    const commentCountMap = {}; // 主评论数量（包括自评）

    Object.keys(workComments).forEach((workNumber) => {
      const comments = workComments[workNumber];
      const workOwner = workOwnerMap[workNumber];
      const isDQ = workDQMap[workNumber];

      commentCountMap[workNumber] = comments.length;

      // 排除作者自评计算正式评分
      const validRatings = comments.filter((c) => c._owner !== workOwner);

      let highWeightSum = 0;
      let highWeightCount = 0;
      let lowWeightSum = 0;
      let lowWeightCount = 0;

      validRatings.forEach((comment) => {
        const isHighQuality = userQualityMap[comment._owner] || false;
        if (isHighQuality) {
          highWeightSum += comment.score;
          highWeightCount++;
        } else {
          lowWeightSum += comment.score;
          lowWeightCount++;
        }
      });

      const totalRatings = highWeightCount + lowWeightCount;
      const weightedAverage =
        totalRatings > 0
          ? (highWeightSum * 2 + lowWeightSum) /
            (highWeightCount * 2 + lowWeightCount)
          : 0;
      const originalAverage =
        totalRatings > 0 ? (highWeightSum + lowWeightSum) / totalRatings : 0;
      const ratio =
        lowWeightCount > 0
          ? highWeightCount / lowWeightCount
          : highWeightCount > 0
          ? 999
          : 0;

      workRatings[workNumber] = {
        numRatings: totalRatings,
        weightedAverage: weightedAverage,
        originalAverage: originalAverage,
        highWeightCount: highWeightCount,
        lowWeightCount: lowWeightCount,
        ratio: ratio,
        isDQ: isDQ,
      };
    });

    return {
      workRatings: workRatings,
      userQualityMap: userQualityMap,
      workOwnerMap: workOwnerMap,
      workDQMap: workDQMap,
      commentCountMap: commentCountMap,
    };
  } catch (error) {
    console.error("批量获取评分数据失败:", error);
    return {
      workRatings: {},
      userQualityMap: {},
      workOwnerMap: {},
      workDQMap: {},
      commentCountMap: {},
    };
  }
}

/**
 * 批量检查用户权重
 * @param {Array<string>} userIds - 用户ID数组
 * @returns {Promise<Object>} { userId: boolean }
 */
async function batchCheckUserQuality(userIds) {
  const qualityMap = {};

  try {
    // 查询所有已注册用户
    const registrations = await wixData
      .query(COLLECTIONS.REGISTRATIONS)
      .hasSome("_owner", userIds)
      .limit(1000)
      .find();

    // 建立用户到isHighQuality的映射
    registrations.items.forEach((reg) => {
      qualityMap[reg._owner] = reg.isHighQuality === true;
    });

    // 未注册的用户默认为 false
    userIds.forEach((userId) => {
      if (!(userId in qualityMap)) {
        qualityMap[userId] = false;
      }
    });

    return qualityMap;
  } catch (error) {
    console.error("批量检查用户权重失败:", error);
    // 失败时返回所有用户权重为 false
    userIds.forEach((userId) => {
      qualityMap[userId] = false;
    });
    return qualityMap;
  }
}

/**
 * 获取作品的加权评分统计数据
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 加权评分数据
 */
export async function getWorkWeightedRatingData(workNumber) {
  try {
    const comments = await fetchAllMainComments({ workNumber });

    const work = await getWorkInfo(workNumber);
    if (!work) {
      return {
        numRatings: 0,
        weightedAverage: 0,
        originalAverage: 0,
        highWeightCount: 0,
        lowWeightCount: 0,
        ratio: 0,
        userQualityMap: {},
      };
    }

    // 排除作者自评
    const validRatings = comments.filter((c) => c._owner !== work._owner);

    // 构建用户权重映射
    const userQualityMap = {};
    let highWeightSum = 0;
    let highWeightCount = 0;
    let lowWeightSum = 0;
    let lowWeightCount = 0;

    for (const comment of validRatings) {
      const isHighQuality = await isUserHighQuality(comment._owner);
      userQualityMap[comment._owner] = isHighQuality;

      if (isHighQuality) {
        highWeightSum += comment.score;
        highWeightCount++;
      } else {
        lowWeightSum += comment.score;
        lowWeightCount++;
      }
    }

    const totalRatings = highWeightCount + lowWeightCount;

    // 加权平均分 = (高权重总和 × 2 + 低权重总和) / (高权重人数 × 2 + 低权重人数)
    const weightedAverage =
      totalRatings > 0
        ? (highWeightSum * 2 + lowWeightSum) /
          (highWeightCount * 2 + lowWeightCount)
        : 0;

    // 原始平均分
    const originalAverage =
      totalRatings > 0 ? (highWeightSum + lowWeightSum) / totalRatings : 0;

    // 当前高低权重比例
    const ratio =
      lowWeightCount > 0
        ? highWeightCount / lowWeightCount
        : highWeightCount > 0
        ? 999
        : 0;

    return {
      numRatings: validRatings.length,
      weightedAverage: weightedAverage,
      originalAverage: originalAverage,
      highWeightCount: highWeightCount,
      lowWeightCount: lowWeightCount,
      ratio: ratio,
      userQualityMap: userQualityMap,
    };
  } catch (error) {
    // console.error('获取加权评分数据失败:', error);
    return {
      numRatings: 0,
      weightedAverage: 0,
      originalAverage: 0,
      highWeightCount: 0,
      lowWeightCount: 0,
      ratio: 0,
      userQualityMap: {},
    };
  }
}

/**
 * 计算高低权重比例均衡因子
 * @param {number} highWeightCount - 高权重评分数
 * @param {number} lowWeightCount - 低权重评分数
 * @param {boolean} isUserHighQuality - 当前用户是否是高权重
 * @returns {number} 均衡因子（0.9-1.1）
 */
function calculateBalanceFactor(
  highWeightCount,
  lowWeightCount,
  isUserHighQuality
) {
  // 目标比例：高:低 = 1:3 (25%占比)
  // 均衡区间：20%-30%占比

  if (highWeightCount === 0 && lowWeightCount === 0) {
    return 1.0; // 没有评分，无需调整
  }

  const totalCount = highWeightCount + lowWeightCount;
  const highPercentage = highWeightCount / totalCount; // 高权重占比

  // 均衡区间：20%-30%
  const lowerBound = 0.2; // 20%
  const upperBound = 0.3; // 30%

  // 在均衡区间内，不调整
  if (highPercentage >= lowerBound && highPercentage <= upperBound) {
    return 1.0;
  }

  // 高权重评分过多（占比 > 30%）
  if (highPercentage > upperBound) {
    // 高权重用户看到的权重降低，低权重用户看到的权重提高
    return isUserHighQuality
      ? 1 - BALANCE_FACTOR_ADJUSTMENT
      : 1 + BALANCE_FACTOR_ADJUSTMENT;
  }

  // 高权重评分不足（占比 < 20%）
  if (highPercentage < lowerBound) {
    // 高权重用户看到的权重提高，低权重用户看到的权重降低
    return isUserHighQuality
      ? 1 + BALANCE_FACTOR_ADJUSTMENT
      : 1 - BALANCE_FACTOR_ADJUSTMENT;
  }

  return 1.0;
}

/**
 * 检查任务是否需要刷新
 * @param {Object} taskRecord - 任务记录
 * @returns {boolean} 是否需要刷新
 */
function shouldRefreshTasks(taskRecord) {
  // 如果没有刷新时间记录，需要刷新
  if (!taskRecord.lastRefreshTime) {
    return true;
  }

  // 计算距离上次刷新的小时数
  const now = new Date();
  const lastRefresh = new Date(taskRecord.lastRefreshTime);
  const hoursSinceRefresh = (now - lastRefresh) / (1000 * 60 * 60);

  // 如果超过刷新间隔，需要刷新
  return hoursSinceRefresh >= TASK_REFRESH_HOURS;
}

/**
 * 计算下次刷新时间
 * @param {Date} lastRefreshTime - 上次刷新时间
 * @returns {Date} 下次刷新时间
 */
function getNextRefreshTime(lastRefreshTime) {
  if (!lastRefreshTime) {
    return new Date();
  }

  const nextRefresh = new Date(lastRefreshTime);
  nextRefresh.setHours(nextRefresh.getHours() + TASK_REFRESH_HOURS);
  return nextRefresh;
}

/**
 * 获取用户任务记录
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 任务记录
 */
async function getUserTaskRecord(
  userId,
  { createIfMissing = true, requireSubmittedWork = false } = {}
) {
  try {
    const results = await wixData
      .query(COLLECTIONS.USER_TASKS)
      .eq("userId", userId)
      .find();

    if (results.items.length === 0) {
      // 没有记录时，根据配置决定是否创建
      if (!createIfMissing) {
        return null;
      }

      // 需要提交作品才创建记录时，先检查资格
      if (requireSubmittedWork) {
        const hasSubmittedWork = await checkUserHasSubmittedWork(userId);
        if (!hasSubmittedWork) {
          return null;
        }
      }

      // 创建新记录
      const newRecord = {
        userId: userId,
        currentTasks: [], // 改为任务列表（最多3条）
        completedTasks: [],
        totalCompleted: 0,
        lastRefreshTime: new Date(), // 初始化刷新时间
      };

      try {
        const inserted = await wixData.insert(COLLECTIONS.USER_TASKS, newRecord);
        return inserted;
      } catch (insertError) {
        // 插入失败可能是因为并发创建，重新查询
        // console.log(`插入记录失败，重新查询: ${userId}`);
        const retryResults = await wixData
          .query(COLLECTIONS.USER_TASKS)
          .eq("userId", userId)
          .find();
        
        if (retryResults.items.length > 0) {
          return retryResults.items[0];
        }
        
        // 如果还是没有，抛出原始错误
        throw insertError;
      }
    }

    // 【修复】如果查询到多个重复记录，自动清理多余的
    if (results.items.length > 1) {
      console.warn(`用户 ${userId} 有 ${results.items.length} 个重复的任务记录，正在自动清理...`);
      
      // 保留第一条记录（通常是最早创建的），删除其他重复记录
      const recordToKeep = results.items[0];
      for (let i = 1; i < results.items.length; i++) {
        try {
          await wixData.remove(COLLECTIONS.USER_TASKS, results.items[i]._id);
          console.log(`已删除用户 ${userId} 的重复记录 ${i}/${results.items.length - 1}`);
        } catch (removeError) {
          console.error(`删除重复记录失败:`, removeError);
        }
      }
      
      return recordToKeep;
    }

    return results.items[0];
  } catch (error) {
    // console.error('获取用户任务记录失败:', error);
    throw error;
  }
}

/**
 * 获取用户已完成的评分作品列表
 * @param {string} userId - 用户ID
 * @returns {Promise<number[]>} 作品序号数组
 */
async function getUserCompletedRatings(userId) {
  try {
    let allComments = [];
    let hasMore = true;
    let skipCount = 0;
    const limit = 100;

    while (hasMore) {
      const results = await wixData
        .query(COLLECTIONS.COMMENTS)
        .eq("_owner", userId)
        .isEmpty("replyTo")
        .skip(skipCount)
        .limit(limit)
        .find();

      allComments = allComments.concat(results.items);
      skipCount += results.items.length;
      hasMore = results.items.length === limit;
    }

    // 提取作品序号（去重）
    const workNumbers = [...new Set(allComments.map((c) => c.workNumber))];
    return workNumbers;
  } catch (error) {
    // console.error('获取用户评分记录失败:', error);
    return [];
  }
}

/**
 * 获取作品信息
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object|null>} 作品信息
 */
async function getWorkInfo(workNumber) {
  try {
    const results = await wixData
      .query(COLLECTIONS.WORKS)
      .eq("sequenceId", workNumber)
      .find();

    if (results.items.length > 0) {
      return results.items[0];
    }
    return null;
  } catch (error) {
    // console.error('获取作品信息失败:', error);
    return null;
  }
}

/**
 * 获取用户自己的所有作品序号（数组形式）
 * @param {string} userId - 用户ID
 * @returns {Promise<number[]>} 作品序号数组
 */
async function getUserOwnWorks(userId) {
  try {
    const results = await wixData
      .query(COLLECTIONS.WORKS)
      .eq("_owner", userId)
      .limit(1000) // 支持多个作品
      .find();

    // 返回所有作品的序号数组
    return results.items.map((work) => work.sequenceId);
  } catch (error) {
    // console.error('获取用户作品失败:', error);
    return []; // 返回空数组而不是null
  }
}

/**
 * 统计每个作品当前被多少用户持有（当前任务列表中）
 * @param {string} [excludeUserId] - 可选，排除指定用户（避免自身记录影响分配）
 * @returns {Promise<Record<number, number>>}
 */
async function getCurrentTaskAssignmentCounts(excludeUserId) {
  const assignmentCounts = {};

  // 遍历 UserRatingTasks，获取所有 currentTasks
  let results = await wixData
    .query(COLLECTIONS.USER_TASKS)
    .limit(1000)
    .find();

  const processBatch = (items) => {
    for (const record of items) {
      if (excludeUserId && record.userId === excludeUserId) {
        continue;
      }

      // 已达成目标的用户不再计入并发占用，避免过度抑制分配
      if ((record.totalCompleted || 0) >= TARGET_USER_COMPLETION) {
        continue;
      }

      (record.currentTasks || []).forEach((task) => {
        if (!task || task.workNumber === undefined || task.workNumber === null) {
          return;
        }
        assignmentCounts[task.workNumber] =
          (assignmentCounts[task.workNumber] || 0) + 1;
      });
    }
  };

  processBatch(results.items);

  while (results.hasNext && results.hasNext()) {
    results = await results.next();
    processBatch(results.items);
  }

  return assignmentCounts;
}

/**
 * 计算作品提交天数
 * @param {Object} work - 作品对象
 * @returns {number} 天数
 */
function getDaysSinceSubmission(work) {
  const now = new Date();
  const submissionDate = new Date(work._createdDate);
  const diffTime = Math.abs(now - submissionDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
}

/**
 * 获取所有用户的任务管理数据（管理员专用）- 优化版
 * 包含详细的权重算法信息
 */
export async function getAllUsersTaskManagementData() {
  try {
    // 1. 并行获取所有基础数据
    const [allTaskRecords, allRegistrations, allWorks, allComments] =
      await Promise.all([
        wixData.query(COLLECTIONS.USER_TASKS).limit(1000).find(),
        wixData.query(COLLECTIONS.REGISTRATIONS).limit(1000).find(),
        wixData.query(COLLECTIONS.WORKS).limit(1000).find(),
        fetchAllMainComments(),
      ]);

    // 2. 构建用户高权重映射
    const userQualityMap = {};
    allRegistrations.items.forEach((reg) => {
      userQualityMap[reg._owner] = reg.isHighQuality === true;
    });

    // 3. 构建作品信息映射
    const worksMap = {};
    allWorks.items.forEach((work) => {
      worksMap[work.sequenceId] = work;
    });

    // 4. 构建评论映射（按作品分组）
    const commentsMap = {};
    // 【性能优化】同时构建用户→已评分作品的映射，避免后续逐个用户查询
    const userRatedWorksMap = {};

    allComments.forEach((comment) => {
      if (!commentsMap[comment.workNumber]) {
        commentsMap[comment.workNumber] = [];
      }
      commentsMap[comment.workNumber].push(comment);

      // 记录用户已评分作品
      if (!userRatedWorksMap[comment._owner]) {
        userRatedWorksMap[comment._owner] = new Set();
      }
      userRatedWorksMap[comment._owner].add(comment.workNumber);
    });

    // 5. 预计算所有涉及作品的权重数据（批量处理）
    const allTaskWorkNumbers = new Set();
    allTaskRecords.items.forEach((record) => {
      (record.currentTasks || []).forEach((task) => {
        allTaskWorkNumbers.add(task.workNumber);
      });
    });

    const workWeightDataMap = {};
    for (const workNumber of allTaskWorkNumbers) {
      const work = worksMap[workNumber];
      if (!work) continue;

      const comments = commentsMap[workNumber] || [];
      const validRatings = comments.filter((c) => c._owner !== work._owner);

      let highWeightSum = 0;
      let highWeightCount = 0;
      let lowWeightSum = 0;
      let lowWeightCount = 0;

      for (const comment of validRatings) {
        const isHighQuality = userQualityMap[comment._owner] || false;
        if (isHighQuality) {
          highWeightSum += comment.score;
          highWeightCount++;
        } else {
          lowWeightSum += comment.score;
          lowWeightCount++;
        }
      }

      const ratio =
        lowWeightCount > 0
          ? highWeightCount / lowWeightCount
          : highWeightCount > 0
          ? 999
          : 0;

      workWeightDataMap[workNumber] = {
        numRatings: validRatings.length,
        highWeightCount: highWeightCount,
        lowWeightCount: lowWeightCount,
        ratio: ratio,
      };
    }

    // 6. 为每个用户计算任务详情（使用预计算的数据）
    const usersTaskData = [];

    for (const taskRecord of allTaskRecords.items) {
      const userId = taskRecord.userId;
      const isHighQuality = userQualityMap[userId] || false;
      const currentTasks = taskRecord.currentTasks || [];

      const tasksWithDetails = [];
      for (const task of currentTasks) {
        const workInfo = worksMap[task.workNumber];
        if (!workInfo) continue;

        const weightData = workWeightDataMap[task.workNumber] || {
          numRatings: 0,
          highWeightCount: 0,
          lowWeightCount: 0,
          ratio: 0,
        };

        // 【修复】使用实时统计的评论数，而不是数据库中的 currentRatingCount
        workInfo.currentRatingCount = weightData.numRatings;

        // 计算基础冷门权重（不含均衡因子）
        const baseWeight = calculateBaseColdnessWeight(workInfo, weightData.numRatings);

        // 计算均衡因子
        const balanceFactor = calculateBalanceFactor(
          weightData.highWeightCount,
          weightData.lowWeightCount,
          isHighQuality
        );

        // 最终权重使用与实际分配一致的算法（含均衡因子一次性取整）
        const finalWeight = calculateColdnessWeightOptimized(
          workInfo,
          weightData.numRatings,
          weightData.highWeightCount,
          weightData.lowWeightCount,
          isHighQuality
        );

        tasksWithDetails.push({
          workNumber: task.workNumber,
          workTitle: workInfo.firstName || "未命名作品",
          baseWeight: baseWeight,
          balanceFactor: balanceFactor,
          finalWeight: finalWeight,
          currentRatings: weightData.numRatings,
          highWeightCount: weightData.highWeightCount,
          lowWeightCount: weightData.lowWeightCount,
          ratio: weightData.ratio,
          ratioStatus: getRatioStatus(weightData.ratio),
          daysSinceSubmission: getDaysSinceSubmission(workInfo),
        });
      }

      // 获取用户所有评论的作品
      const completedTasks = [...(taskRecord.completedTasks || [])];
      const completedSet = new Set(completedTasks);
      const allUserRatings = userRatedWorksMap[userId]
        ? Array.from(userRatedWorksMap[userId])
        : [];
      const freeRatings = allUserRatings.filter(
        (workNum) => !completedSet.has(workNum)
      );

      usersTaskData.push({
        userId: userId,
        isHighQuality: isHighQuality,
        currentTasks: tasksWithDetails,
        completedTasks: completedTasks.sort((a, b) => b - a), // 任务完成的作品
        freeRatings: freeRatings.sort((a, b) => b - a), // 自主评论的作品
        completedCount: taskRecord.totalCompleted || 0,
        targetCompletion: TARGET_USER_COMPLETION,
        lastRefreshTime: taskRecord.lastRefreshTime,
      });
    }

    // 7. 计算整体统计
    const totalHighQualityUsers = Object.values(userQualityMap).filter(
      (v) => v
    ).length;
    const totalLowQualityUsers =
      allRegistrations.items.length - totalHighQualityUsers;

    return {
      users: usersTaskData,
      stats: {
        totalUsers: usersTaskData.length,
        highQualityUsers: totalHighQualityUsers,
        lowQualityUsers: totalLowQualityUsers,
        targetRatio: TARGET_HIGH_LOW_RATIO,
        tolerance: RATIO_TOLERANCE,
      },
    };
  } catch (error) {
    console.error("获取任务管理数据失败:", error);
    throw error;
  }
}


/**
 * 获取比例状态描述
 * @param {number} ratio - 高低权重比值（高/低），注意不是占比
 * @returns {string} 状态描述
 */
function getRatioStatus(ratio) {
  // 将"高/低"比值转换为高权重占比
  // 公式：highPercentage = ratio / (1 + ratio) = high/low / (1 + high/low) = high / (low + high)
  let highPercentage;

  if (ratio === 0) {
    // 没有高权重评分
    highPercentage = 0;
  } else if (ratio >= 999) {
    // 只有高权重评分（没有低权重）
    highPercentage = 1;
  } else {
    // 正常情况：转换比值为占比
    highPercentage = ratio / (1 + ratio);
  }

  // 均衡区间：20%-30%（目标比例1:3）
  if (highPercentage >= 0.2 && highPercentage <= 0.3) {
    return "均衡";
  } else if (highPercentage > 0.3) {
    return "高权重过多";
  } else {
    return "高权重不足";
  }
}

/**
 * 强制刷新指定用户的任务（管理员专用）
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 刷新结果
 */
export async function forceRefreshUserTasks(userId) {
  try {
    // console.log(`\n========== 强制刷新用户任务: ${userId} ==========`);

    // 获取用户任务记录
    const taskRecord = await getUserTaskRecord(userId, {
      requireSubmittedWork: true,
    });

    if (!taskRecord) {
      return {
        success: false,
        message: "用户未提交作品或无任务记录，未创建空记录",
      };
    }
    // console.log(`原任务列表:`, taskRecord.currentTasks?.map(t => `#${t.workNumber}(${t.weight})`).join(', '));

    // 清空当前任务，强制重新生成
    taskRecord.currentTasks = [];
    taskRecord.lastRefreshTime = new Date();

    // 清除用户权重缓存，确保使用最新数据
    if (userId in userQualityCache) {
      delete userQualityCache[userId];
    }

    // console.log(`开始生成新任务...`);

    // 生成新任务
    const newTasks = await generateUserTasks(userId, taskRecord, 3);
    taskRecord.currentTasks = newTasks;

    // console.log(`新任务列表:`, newTasks.map(t => `#${t.workNumber}(${t.weight})`).join(', '));

    // 保存到数据库
    await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
    // console.log(`任务已保存到数据库`);
    // console.log(`========== 刷新完成 ==========\n`);

    return {
      success: true,
      message: "任务已刷新",
      newTasksCount: newTasks.length,
      newTasks: newTasks,
    };
  } catch (error) {
    console.error("强制刷新用户任务失败:", error);
    return {
      success: false,
      message: "刷新失败: " + error.message,
    };
  }
}

/**
 * 获取所有作品的权重对比数据（管理员专用）
 * 显示每个作品对于高权重和低权重用户的权重差异
 */
export async function getAllWorksWeightComparison() {
  try {
    // 1. 并行获取所有基础数据
    const [allWorks, allComments, allRegistrations] = await Promise.all([
      wixData.query(COLLECTIONS.WORKS).ne("isDq", true).limit(1000).find(),
      fetchAllMainComments(),
      wixData.query(COLLECTIONS.REGISTRATIONS).limit(1000).find(),
    ]);

    // 2. 构建用户权重映射
    const userQualityMap = {};
    allRegistrations.items.forEach((reg) => {
      userQualityMap[reg._owner] = reg.isHighQuality === true;
    });

    // 3. 构建评论映射
    const commentsMap = {};
    allComments.forEach((comment) => {
      if (!commentsMap[comment.workNumber]) {
        commentsMap[comment.workNumber] = [];
      }
      commentsMap[comment.workNumber].push(comment);
    });

    // 4. 计算每个作品的权重数据
    const worksWeightData = [];

    for (const work of allWorks.items) {
      const comments = commentsMap[work.sequenceId] || [];
      const validRatings = comments.filter((c) => c._owner !== work._owner);

      // 统计高低权重评分
      let highWeightCount = 0;
      let lowWeightCount = 0;

      for (const comment of validRatings) {
        if (userQualityMap[comment._owner]) {
          highWeightCount++;
        } else {
          lowWeightCount++;
        }
      }

      const ratio =
        lowWeightCount > 0
          ? highWeightCount / lowWeightCount
          : highWeightCount > 0
          ? 999
          : 0;

      // 【修复】使用实时统计的评论数，而不是数据库中的 currentRatingCount
      work.currentRatingCount = validRatings.length;

      // 【关键修复】使用与实际分配完全一致的权重计算逻辑
      // 对于高权重用户的最终权重
      const finalWeightHigh = calculateColdnessWeightOptimized(
        work,
        validRatings.length,
        highWeightCount,
        lowWeightCount,
        true // isUserHighQuality = true
      );

      // 对于低权重用户的最终权重
      const finalWeightLow = calculateColdnessWeightOptimized(
        work,
        validRatings.length,
        highWeightCount,
        lowWeightCount,
        false // isUserHighQuality = false
      );

      // 计算基础权重（不含均衡因子，仅用于显示）
      const baseWeight = calculateBaseColdnessWeight(work, validRatings.length);

      // 计算均衡因子（仅用于显示）
      const balanceFactorHigh =
        validRatings.length >= 1
          ? calculateBalanceFactor(highWeightCount, lowWeightCount, true)
          : 1.0;
      const balanceFactorLow =
        validRatings.length >= 1
          ? calculateBalanceFactor(highWeightCount, lowWeightCount, false)
          : 1.0;

      worksWeightData.push({
        sequenceId: work.sequenceId,
        title: work.firstName || "未命名作品",
        currentRatings: validRatings.length,
        highWeightCount: highWeightCount,
        lowWeightCount: lowWeightCount,
        ratio: ratio,
        ratioStatus: getRatioStatus(ratio),
        daysSinceSubmission: getDaysSinceSubmission(work),
        baseWeight: baseWeight,
        // 对于高权重用户（使用实际分配的算法）
        balanceFactorHigh: balanceFactorHigh,
        finalWeightHigh: finalWeightHigh,
        // 对于低权重用户（使用实际分配的算法）
        balanceFactorLow: balanceFactorLow,
        finalWeightLow: finalWeightLow,
        // 权重差异
        weightDifference: finalWeightHigh - finalWeightLow,
      });
    }

    // 5. 按权重排序（从高到低），便于查看最需要关注的作品
    // 优先按Qualified用户权重排序（因为他们的权重更能代表作品的冷门程度）
    worksWeightData.sort((a, b) => {
      // 先按高权重用户的最终权重排序
      if (b.finalWeightHigh !== a.finalWeightHigh) {
        return b.finalWeightHigh - a.finalWeightHigh;
      }
      // 权重相同时，按评分数升序（评分少的更需要关注）
      if (a.currentRatings !== b.currentRatings) {
        return a.currentRatings - b.currentRatings;
      }
      // 最后按作品ID排序
      return a.sequenceId - b.sequenceId;
    });

    return {
      works: worksWeightData,
      config: {
        targetRatio: TARGET_HIGH_LOW_RATIO,
        tolerance: RATIO_TOLERANCE,
        balanceAdjustment: BALANCE_FACTOR_ADJUSTMENT,
      },
      note: "此表显示所有作品的理论权重，实际分配会排除用户已完成/已评论/自己的作品",
    };
  } catch (error) {
    console.error("获取作品权重对比数据失败:", error);
    throw error;
  }
}
