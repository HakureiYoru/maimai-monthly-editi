/**
 * 评分任务管理系统 - 后端核心算法
 * 
 * 功能：
 * 1. 基于冷门权重的任务分配
 * 2. 单任务推送机制
 * 3. 自动同步用户评分记录
 */

import wixData from 'wix-data';

const COLLECTIONS = {
  USER_TASKS: 'UserRatingTasks',
  COMMENTS: 'BOFcomment',
  WORKS: 'enterContest034',
  REGISTRATIONS: 'jobApplication089'
};

const TARGET_RATING_COUNT = 20; // 目标评分数
const TARGET_USER_COMPLETION = 10; // 用户目标完成数
const TASK_REFRESH_HOURS = 24; // 任务刷新间隔（小时），1/30小时=2分钟（调试用） 1=1小时

// 高权重评分系统配置
const TARGET_HIGH_LOW_RATIO = 0.5; // 目标高低权重比例 1:2 = 0.5
const RATIO_TOLERANCE = 0.1; // 容忍度 ±20% → 0.4到0.6可接受
const BALANCE_FACTOR_ADJUSTMENT = 0.3; // 权重调整幅度 30%

// 用户权重缓存
let userQualityCache = {};

/**
 * 获取用户任务数据（主入口）
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 任务数据
 */
export async function getUserTaskData(userId) {
  try {
    // 1. 获取或创建用户任务记录
    let taskRecord = await getUserTaskRecord(userId);
    
    // 2. 检查是否需要刷新任务（基于时间）
    const needsRefresh = shouldRefreshTasks(taskRecord);
    if (needsRefresh) {
      // console.log(`用户 ${userId} 任务已超时，将刷新任务列表`);
      // 清空当前任务，强制重新生成
      taskRecord.currentTasks = [];
      taskRecord.lastRefreshTime = new Date();
    }
    
    // 3. 生成当前任务列表（最多3条）
    const currentTasks = await generateUserTasks(userId, taskRecord, 3);
    
    // 4. 更新任务列表和刷新时间到数据库
    if (currentTasks.length > 0 || needsRefresh) {
      taskRecord.currentTasks = currentTasks;
      if (needsRefresh || !taskRecord.lastRefreshTime) {
        taskRecord.lastRefreshTime = new Date();
      }
      await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
    }

    // 5. 获取用户所有评分记录，计算自主评论的作品
    const allUserRatings = await getUserCompletedRatings(userId);
    const freeRatings = allUserRatings.filter(workNum => 
      !taskRecord.completedTasks.includes(workNum)
    );

    // 6. 获取用户是否是高权重用户
    const isHighQuality = await isUserHighQuality(userId);
    
    // 7. 获取用户自己的作品编号（用于前端显示）
    const userOwnWorks = await getUserOwnWorks(userId);
    
    // 8. 判断用户是否已完成任务目标
    const hasCompletedTarget = taskRecord.totalCompleted >= TARGET_USER_COMPLETION;
    
    return {
      currentTasks: currentTasks,
      completedTasks: taskRecord.completedTasks.sort((a, b) => b - a),
      freeRatings: freeRatings.sort((a, b) => b - a),
      totalCompleted: taskRecord.totalCompleted,
      targetCompletion: TARGET_USER_COMPLETION,
      lastRefreshTime: taskRecord.lastRefreshTime,
      nextRefreshTime: getNextRefreshTime(taskRecord.lastRefreshTime),
      isHighQuality: isHighQuality, // 用户身份标识
      ownWorks: userOwnWorks, // 用户自己的作品列表
      hasCompletedTarget: hasCompletedTarget // 是否已完成目标
    };
    
  } catch (error) {
    // console.error('获取用户任务数据失败:', error);
    throw error;
  }
}

/**
 * 生成用户任务列表（最多 limit 条）
 * @param {string} userId
 * @param {object} taskRecord
 * @param {number} limit
 * @returns {Promise<Array<{workNumber:number, weight:number, currentRatings:number}>>}
 */
async function generateUserTasks(userId, taskRecord, limit = 3) {
  try {
    const completedWorks = taskRecord.completedTasks || [];
    const userOwnWorks = await getUserOwnWorks(userId); // 获取用户所有作品
    
    // 获取用户所有已经评论过的作品（包括自评和其他评论）
    const userRatedWorks = await getUserCompletedRatings(userId);

    // 查询所有作品，排除被淘汰的作品
    const allWorksResult = await wixData
      .query(COLLECTIONS.WORKS)
      .ne('isDq', true)
      .limit(1000)
      .find();

    const candidateWorks = [];
    for (const work of allWorksResult.items) {
      // 排除条件：
      // 1. 已在完成任务列表中
      // 2. 是用户自己的作品（支持多个作品）
      // 3. 用户已经评论过的作品
      if (completedWorks.includes(work.sequenceId) || 
          userOwnWorks.includes(work.sequenceId) ||
          userRatedWorks.includes(work.sequenceId)) {
        continue;
      }
      
      // 实时获取有效评分数（确保数据最新）
      const validRatingCount = await getWorkValidRatingCount(work.sequenceId);
      
      // 更新work对象的currentRatingCount以确保权重计算使用最新数据
      work.currentRatingCount = validRatingCount;
      
      // 使用增强的冷门权重计算（包含高低权重均衡因子）
      const coldnessWeight = await calculateColdnessWeight(work, userId);
      if (coldnessWeight <= 0) continue;
      
      candidateWorks.push({
        workNumber: work.sequenceId,
        weight: coldnessWeight,
        currentRatings: validRatingCount,
        submissionDate: work._createdDate
      });
    }

    if (candidateWorks.length === 0) return [];
    candidateWorks.sort((a, b) => b.weight - a.weight);
    
    // 返回可用的任务数量，不强制凑齐 limit 个
    return candidateWorks.slice(0, Math.min(limit, candidateWorks.length));
  } catch (e) {
    // console.error('生成用户任务失败:', e);
    return [];
  }
}

/**
 * 检查作品是否在用户的任务列表中
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 检查结果
 */
export async function checkIfWorkInTaskList(userId, workNumber) {
  try {
    const taskRecord = await getUserTaskRecord(userId);
    
    // console.log(`[检查] 作品 #${workNumber}, 已完成: [${taskRecord.completedTasks.join(', ')}]`);
    
    // 检查是否在已完成列表中
    if (taskRecord.completedTasks.includes(workNumber)) {
      // console.log(`[检查] ✓ 作品 #${workNumber} 在已完成列表中`);
      return {
        inTaskList: true,
        alreadyCompleted: true
      };
    }
    
    // 检查是否在当前任务列表中（3条任务）
    const currentTasksList = taskRecord.currentTasks || [];
    const taskNums = currentTasksList.map(t => t.workNumber);
    // console.log(`[检查] 当前任务列表: [${taskNums.join(', ')}]`);
    
    const inCurrentTasks = currentTasksList.some(t => t.workNumber === workNumber);
    // console.log(`[检查] ${inCurrentTasks ? '✓' : '✗'} 作品 #${workNumber} ${inCurrentTasks ? '在' : '不在'}任务列表中`);
    
    return {
      inTaskList: inCurrentTasks,
      alreadyCompleted: false
    };
    
  } catch (error) {
    // console.error('检查任务列表失败:', error);
    return {
      inTaskList: false,
      alreadyCompleted: false
    };
  }
}

/**
 * 标记任务完成
 * @param {string} userId - 用户ID
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 完成结果
 */
export async function markTaskCompleted(userId, workNumber) {
  try {
    // console.log(`\n========== 标记任务: 用户 ${userId}, 作品 #${workNumber} ==========`);
    
    const taskRecord = await getUserTaskRecord(userId);
    // console.log(`[标记] 当前已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);
    
    // 检查用户是否已完成任务目标
    const hasCompletedTarget = taskRecord.totalCompleted >= TARGET_USER_COMPLETION;
    // console.log(`[标记] 用户是否已完成目标: ${hasCompletedTarget} (${taskRecord.totalCompleted}/${TARGET_USER_COMPLETION})`);
    
    // 检查这个作品是否在任务列表中
    const taskCheck = await checkIfWorkInTaskList(userId, workNumber);
    // console.log(`[标记] 检查结果: inTaskList=${taskCheck.inTaskList}, alreadyCompleted=${taskCheck.alreadyCompleted}`);
    
    // 如果已经完成过，直接返回
    if (taskCheck.alreadyCompleted) {
      // console.log(`[标记] 作品 #${workNumber} 已在完成列表中，跳过`);
      return {
        success: true,
        taskCompleted: false,
        isInTaskList: true,
        alreadyCompleted: true,
        completedCount: taskRecord.totalCompleted,
        hasCompletedTarget: hasCompletedTarget
      };
    }
    
    // 如果用户已完成目标，不再计入任务指标
    if (hasCompletedTarget) {
      // console.log(`[标记] 用户已完成目标，作品 #${workNumber} 不计入任务进度`);
      return {
        success: true,
        taskCompleted: false,
        isInTaskList: taskCheck.inTaskList,
        alreadyCompleted: false,
        completedCount: taskRecord.totalCompleted,
        hasCompletedTarget: true,
        isColdWork: taskCheck.inTaskList // 标记为冷门作品（在任务列表中但不计入进度）
      };
    }
    
    // 只有在任务列表中且未完成目标的作品才计入完成
    let taskCompleted = false;
    if (taskCheck.inTaskList) {
      // console.log(`[标记] ✓ 作品 #${workNumber} 在任务列表中，添加到完成列表`);
      
      // 添加到完成列表
      taskRecord.completedTasks.push(workNumber);
      taskRecord.totalCompleted = taskRecord.completedTasks.length;
      taskCompleted = true;
      
      // console.log(`[标记] 更新后已完成: [${taskRecord.completedTasks.join(', ')}], 总数: ${taskRecord.totalCompleted}`);
      
      await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
      // console.log(`[标记] 数据库已更新`);
    } else {
      // console.log(`[标记] ✗ 作品 #${workNumber} 不在任务列表中，不计入进度`);
    }
    
    // console.log(`========== 标记任务完成 ==========\n`);
    
    return {
      success: true,
      taskCompleted: taskCompleted,
      isInTaskList: taskCheck.inTaskList,
      alreadyCompleted: false,
      completedCount: taskRecord.totalCompleted,
      hasCompletedTarget: false
    };
    
  } catch (error) {
    // console.error('标记任务完成失败:', error);
    throw error;
  }
}

/**
 * 为用户分配下一个任务（已废弃，改用 generateUserTasks）
 * 保留此函数以兼容同步任务
 */
async function assignNextTask(userId, taskRecord) {
  const tasks = await generateUserTasks(userId, taskRecord, 1);
  return tasks && tasks.length > 0 ? tasks[0] : null;
}

/**
 * 检查用户是否是高权重用户
 * @param {string} userId - 用户ID
 * @returns {Promise<boolean>} 是否是高权重用户
 */
async function isUserHighQuality(userId) {
  // 检查缓存
  if (userId in userQualityCache) {
    return userQualityCache[userId];
  }
  
  try {
    const result = await wixData
      .query(COLLECTIONS.REGISTRATIONS)
      .eq('_owner', userId)
      .find();
    
    const isHighQuality = result.items.length > 0 && result.items[0].isHighQuality === true;
    userQualityCache[userId] = isHighQuality;
    return isHighQuality;
  } catch (error) {
    // console.error('检查用户权重失败:', error);
    userQualityCache[userId] = false;
    return false;
  }
}

/**
 * 获取作品的加权评分统计数据
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object>} 加权评分数据
 */
export async function getWorkWeightedRatingData(workNumber) {
  try {
    const comments = await wixData
      .query(COLLECTIONS.COMMENTS)
      .eq('workNumber', workNumber)
      .isEmpty('replyTo')
      .find();
    
    const work = await getWorkInfo(workNumber);
    if (!work) {
      return { 
        numRatings: 0, 
        weightedAverage: 0, 
        originalAverage: 0,
        highWeightCount: 0, 
        lowWeightCount: 0,
        ratio: 0
      };
    }
    
    // 排除作者自评
    const validRatings = comments.items.filter(c => c._owner !== work._owner);
    
    let highWeightSum = 0;
    let highWeightCount = 0;
    let lowWeightSum = 0;
    let lowWeightCount = 0;
    
    for (const comment of validRatings) {
      const isHighQuality = await isUserHighQuality(comment._owner);
      if (isHighQuality) {
        highWeightSum += comment.score;
        highWeightCount++;
      } else {
        lowWeightSum += comment.score;
        lowWeightCount++;
      }
    }
    
    const totalRatings = highWeightCount + lowWeightCount;
    
    // 加权平均分 = (高权重总和 × 2 + 低权重总和) / (高权重人数 × 2 + 低权重人数)
    const weightedAverage = totalRatings > 0
      ? (highWeightSum * 2 + lowWeightSum) / (highWeightCount * 2 + lowWeightCount)
      : 0;
    
    // 原始平均分
    const originalAverage = totalRatings > 0
      ? (highWeightSum + lowWeightSum) / totalRatings
      : 0;
    
    // 当前高低权重比例
    const ratio = lowWeightCount > 0 ? highWeightCount / lowWeightCount : (highWeightCount > 0 ? 999 : 0);
    
    return {
      numRatings: validRatings.length,
      weightedAverage: weightedAverage,
      originalAverage: originalAverage,
      highWeightCount: highWeightCount,
      lowWeightCount: lowWeightCount,
      ratio: ratio
    };
  } catch (error) {
    // console.error('获取加权评分数据失败:', error);
    return { 
      numRatings: 0, 
      weightedAverage: 0, 
      originalAverage: 0,
      highWeightCount: 0, 
      lowWeightCount: 0,
      ratio: 0
    };
  }
}

/**
 * 计算高低权重比例均衡因子
 * @param {number} highWeightCount - 高权重评分数
 * @param {number} lowWeightCount - 低权重评分数
 * @param {boolean} isUserHighQuality - 当前用户是否是高权重
 * @returns {number} 均衡因子（0.7-1.3）
 */
function calculateBalanceFactor(highWeightCount, lowWeightCount, isUserHighQuality) {
  // 目标比例：高:低 = 1:2 (33.3%占比)
  // 均衡区间：28%-45%占比
  
  if (highWeightCount === 0 && lowWeightCount === 0) {
    return 1.0; // 没有评分，无需调整
  }
  
  const totalCount = highWeightCount + lowWeightCount;
  const highPercentage = highWeightCount / totalCount; // 高权重占比
  
  // 均衡区间：28%-45%
  const lowerBound = 0.28; // 28%
  const upperBound = 0.45; // 45%
  
  // 在均衡区间内，不调整
  if (highPercentage >= lowerBound && highPercentage <= upperBound) {
    return 1.0;
  }
  
  // 高权重评分过多（占比 > 45%）
  if (highPercentage > upperBound) {
    // 高权重用户看到的权重降低，低权重用户看到的权重提高
    return isUserHighQuality ? (1 - BALANCE_FACTOR_ADJUSTMENT) : (1 + BALANCE_FACTOR_ADJUSTMENT);
  }
  
  // 高权重评分不足（占比 < 28%）
  if (highPercentage < lowerBound) {
    // 高权重用户看到的权重提高，低权重用户看到的权重降低
    return isUserHighQuality ? (1 + BALANCE_FACTOR_ADJUSTMENT) : (1 - BALANCE_FACTOR_ADJUSTMENT);
  }
  
  return 1.0;
}

/**
 * 计算作品的冷门权重（0-100）- 增强版，包含高低权重均衡
 * 权重越高表示越冷门，越需要关注
 * 
 * @param {Object} work - 作品对象
 * @param {string} userId - 用户ID（用于计算均衡因子）
 * @returns {Promise<number>} 冷门权重
 */
async function calculateColdnessWeight(work, userId = null) {
  const daysSinceSubmission = getDaysSinceSubmission(work);
  const currentRatings = work.currentRatingCount || 0;
  
  // 已达标，权重为0
  if (currentRatings >= TARGET_RATING_COUNT) {
    return 0;
  }
  
  // 计算期望评分数（基于时间的线性模型）
  let expectedRatings = 0;
  if (daysSinceSubmission <= 7) {
    expectedRatings = Math.floor(daysSinceSubmission * 1.43); // 7天达到10个
  } else if (daysSinceSubmission <= 30) {
    expectedRatings = 10 + Math.floor((daysSinceSubmission - 7) * 0.43); // 30天达到20个
  } else {
    expectedRatings = TARGET_RATING_COUNT;
  }
  
  // 计算评分缺口
  const deficit = Math.max(0, expectedRatings - currentRatings);
  
  // 基础权重：缺口比例 × 系数 + 底数（确保接近目标时仍有权重）
  const deficitRatio = expectedRatings > 0 ? deficit / expectedRatings : 0;
  const baseWeight = deficitRatio * 60 + 15; // 缺口系数60，底数15
  
  // 时间紧迫度加成（大幅加强，确保冷门作品获得足够关注）
  let urgencyBonus = 0;
  
  // 早期冷启动加成
  if (daysSinceSubmission >= 3 && currentRatings < 2) {
    urgencyBonus = 15; // 3天内少于2评
  }
  if (daysSinceSubmission >= 5 && currentRatings < 5) {
    urgencyBonus = 20; // 5天内少于5评
  }
  
  // 中期关注加成
  if (daysSinceSubmission >= 7 && currentRatings < 10) {
    urgencyBonus = 30; // 一周内应达10评
  }
  if (daysSinceSubmission >= 14 && currentRatings < 15) {
    urgencyBonus = 45; // 两周内应达15评
  }
  
  // 后期紧急加成
  if (daysSinceSubmission >= 21 && currentRatings < 18) {
    urgencyBonus = 65; // 三周内应接近目标
  }
  
  // 超期最高优先级
  if (daysSinceSubmission >= 30 && currentRatings < 20) {
    urgencyBonus = 80; // 超过一个月的冷门作品
  }
  
  // 总权重（最大约155：100%缺口×60+15+80加成）
  let totalWeight = baseWeight + urgencyBonus;
  
  // 如果提供了用户ID，应用高低权重均衡因子
  if (userId && currentRatings >= 3) { // 至少有3个评分才考虑均衡
    try {
      const weightData = await getWorkWeightedRatingData(work.sequenceId);
      const userIsHighQuality = await isUserHighQuality(userId); // 修复变量名冲突
      const balanceFactor = calculateBalanceFactor(
        weightData.highWeightCount,
        weightData.lowWeightCount,
        userIsHighQuality
      );
      
      //console.log(`[权重计算] 作品#${work.sequenceId}: 基础${Math.round(totalWeight)} × 均衡${balanceFactor.toFixed(2)} = ${Math.round(totalWeight * balanceFactor)}, 高低比例${weightData.highWeightCount}:${weightData.lowWeightCount}, 用户类型:${userIsHighQuality ? 'Qualified' : '普通'}`);
      
      totalWeight = totalWeight * balanceFactor;
    } catch (error) {
      console.error('应用均衡因子失败，使用基础权重:', error);
    }
  } else if (userId) {
    //console.log(`[权重计算] 作品#${work.sequenceId}: 评分数${currentRatings}<3，不应用均衡因子，使用基础权重${Math.round(totalWeight)}`);
  }
  
  return Math.round(Math.min(100, totalWeight));
}

/**
 * 检查任务是否需要刷新
 * @param {Object} taskRecord - 任务记录
 * @returns {boolean} 是否需要刷新
 */
function shouldRefreshTasks(taskRecord) {
  // 如果没有刷新时间记录，需要刷新
  if (!taskRecord.lastRefreshTime) {
    return true;
  }
  
  // 计算距离上次刷新的小时数
  const now = new Date();
  const lastRefresh = new Date(taskRecord.lastRefreshTime);
  const hoursSinceRefresh = (now - lastRefresh) / (1000 * 60 * 60);
  
  // 如果超过刷新间隔，需要刷新
  return hoursSinceRefresh >= TASK_REFRESH_HOURS;
}

/**
 * 计算下次刷新时间
 * @param {Date} lastRefreshTime - 上次刷新时间
 * @returns {Date} 下次刷新时间
 */
function getNextRefreshTime(lastRefreshTime) {
  if (!lastRefreshTime) {
    return new Date();
  }
  
  const nextRefresh = new Date(lastRefreshTime);
  nextRefresh.setHours(nextRefresh.getHours() + TASK_REFRESH_HOURS);
  return nextRefresh;
}

/**
 * 获取用户任务记录
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 任务记录
 */
async function getUserTaskRecord(userId) {
  try {
    const results = await wixData
      .query(COLLECTIONS.USER_TASKS)
      .eq('userId', userId)
      .find();
    
    if (results.items.length === 0) {
      // 创建新记录
      const newRecord = {
        userId: userId,
        currentTasks: [],  // 改为任务列表（最多3条）
        completedTasks: [],
        totalCompleted: 0,
        lastRefreshTime: new Date() // 初始化刷新时间
      };
      
      const inserted = await wixData.insert(COLLECTIONS.USER_TASKS, newRecord);
      return inserted;
    }
    
    return results.items[0];
    
  } catch (error) {
    // console.error('获取用户任务记录失败:', error);
    throw error;
  }
}

/**
 * 获取用户已完成的评分作品列表
 * @param {string} userId - 用户ID
 * @returns {Promise<number[]>} 作品序号数组
 */
async function getUserCompletedRatings(userId) {
  try {
    let allComments = [];
    let hasMore = true;
    let skipCount = 0;
    const limit = 100;
    
    while (hasMore) {
      const results = await wixData
        .query(COLLECTIONS.COMMENTS)
        .eq('_owner', userId)
        .isEmpty('replyTo')
        .skip(skipCount)
        .limit(limit)
        .find();
      
      allComments = allComments.concat(results.items);
      skipCount += results.items.length;
      hasMore = results.items.length === limit;
    }
    
    // 提取作品序号（去重）
    const workNumbers = [...new Set(allComments.map(c => c.workNumber))];
    return workNumbers;
    
  } catch (error) {
    // console.error('获取用户评分记录失败:', error);
    return [];
  }
}

/**
 * 获取作品信息
 * @param {number} workNumber - 作品序号
 * @returns {Promise<Object|null>} 作品信息
 */
async function getWorkInfo(workNumber) {
  try {
    const results = await wixData
      .query(COLLECTIONS.WORKS)
      .eq('sequenceId', workNumber)
      .find();
    
    if (results.items.length > 0) {
      return results.items[0];
    }
    return null;
    
  } catch (error) {
    // console.error('获取作品信息失败:', error);
    return null;
  }
}

/**
 * 获取作品的有效评分数（排除作者自评）
 * @param {number} workNumber - 作品序号
 * @returns {Promise<number>} 有效评分数
 */
async function getWorkValidRatingCount(workNumber) {
  try {
    // 获取所有评论
    const comments = await wixData
      .query(COLLECTIONS.COMMENTS)
      .eq('workNumber', workNumber)
      .isEmpty('replyTo')
      .find();
    
    // 获取作品所有者
    const work = await getWorkInfo(workNumber);
    if (!work) return 0;
    
    const workOwnerId = work._owner;
    
    // 排除作者自评
    const validRatings = comments.items.filter(c => c._owner !== workOwnerId);
    
    return validRatings.length;
    
  } catch (error) {
    // console.error('获取作品评分数失败:', error);
    return 0;
  }
}

/**
 * 获取用户自己的所有作品序号（数组形式）
 * @param {string} userId - 用户ID
 * @returns {Promise<number[]>} 作品序号数组
 */
async function getUserOwnWorks(userId) {
  try {
    const results = await wixData
      .query(COLLECTIONS.WORKS)
      .eq('_owner', userId)
      .limit(1000) // 支持多个作品
      .find();
    
    // 返回所有作品的序号数组
    return results.items.map(work => work.sequenceId);
    
  } catch (error) {
    // console.error('获取用户作品失败:', error);
    return []; // 返回空数组而不是null
  }
}

/**
 * 获取用户自己的第一个作品序号（向后兼容，已废弃）
 * @param {string} userId - 用户ID
 * @returns {Promise<number|null>} 作品序号
 * @deprecated 请使用 getUserOwnWorks
 */
async function getUserOwnWork(userId) {
  const works = await getUserOwnWorks(userId);
  return works.length > 0 ? works[0] : null;
}

/**
 * 计算作品提交天数
 * @param {Object} work - 作品对象
 * @returns {number} 天数
 */
function getDaysSinceSubmission(work) {
  const now = new Date();
  const submissionDate = new Date(work._createdDate);
  const diffTime = Math.abs(now - submissionDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays;
}

/**
 * 同步所有用户的任务状态（定时任务）
 * 每日运行一次 - 主要用于为没有任务的用户分配任务
 */
export async function syncAllUserRatings() {
  try {
    // console.log('开始同步所有用户任务状态...');
    
    // 获取所有已报名用户
    const registeredUsers = await getRegisteredUsers();
    
    let successCount = 0;
    let errorCount = 0;
    
    for (const user of registeredUsers) {
      try {
        const taskRecord = await getUserTaskRecord(user.userId);
        
        // 只负责为没有任务的用户分配任务
        // 不再同步所有评分记录，因为只有任务列表中的作品才应该计入
        if ((!taskRecord.currentTask || taskRecord.currentTask.status === 'completed') &&
            taskRecord.totalCompleted < TARGET_USER_COMPLETION) {
          await assignNextTask(user.userId, taskRecord);
        }
        
        successCount++;
        
      } catch (error) {
        // console.error(`同步用户 ${user.userId} 失败:`, error);
        errorCount++;
      }
    }
    
    // console.log(`同步完成: 成功 ${successCount}, 失败 ${errorCount}`);
    
    return {
      success: true,
      successCount,
      errorCount
    };
    
  } catch (error) {
    // console.error('同步任务状态失败:', error);
    throw error;
  }
}

/**
 * 获取所有已报名的参赛用户
 * @returns {Promise<Array>} 用户列表
 */
async function getRegisteredUsers() {
  try {
    let allRegistrations = [];
    let hasMore = true;
    let skipCount = 0;
    const limit = 100;
    
    while (hasMore) {
      const results = await wixData
        .query(COLLECTIONS.REGISTRATIONS)
        .skip(skipCount)
        .limit(limit)
        .find();
      
      allRegistrations = allRegistrations.concat(results.items);
      skipCount += results.items.length;
      hasMore = results.items.length === limit;
    }
    
    // 提取用户ID（去重）
    const userIds = [...new Set(allRegistrations.map(reg => reg._owner).filter(id => id))];
    
    return userIds.map(userId => ({ userId }));
    
  } catch (error) {
    // console.error('获取参赛用户失败:', error);
    return [];
  }
}

/**
 * 更新所有作品的评分计数（定时任务）
 * 每日运行一次
 */
export async function updateAllWorkRatingCounts() {
  try {
    // console.log('开始更新所有作品评分计数...');
    
    const allWorks = await wixData
      .query(COLLECTIONS.WORKS)
      .limit(1000)
      .find();
    
    let updateCount = 0;
    
    for (const work of allWorks.items) {
      const validRatingCount = await getWorkValidRatingCount(work.sequenceId);
      
      if (work.currentRatingCount !== validRatingCount) {
        work.currentRatingCount = validRatingCount;
        await wixData.update(COLLECTIONS.WORKS, work);
        updateCount++;
      }
    }
    
    // console.log(`更新完成: ${updateCount} 个作品`);
    
    return {
      success: true,
      updateCount
    };
    
  } catch (error) {
    // console.error('更新作品评分计数失败:', error);
    throw error;
  }
}

/**
 * 获取系统统计信息（管理用）
 */
export async function getSystemStats() {
  try {
    // 获取所有任务记录
    const allTasks = await wixData
      .query(COLLECTIONS.USER_TASKS)
      .limit(1000)
      .find();
    
    // 获取所有作品
    const allWorks = await wixData
      .query(COLLECTIONS.WORKS)
      .ne('isDq', true)
      .limit(1000)
      .find();
    
    // 统计用户完成情况
    const completionStats = {
      completed20: 0,
      completed10to19: 0,
      completed1to9: 0,
      completed0: 0
    };
    
    allTasks.items.forEach(task => {
      const count = task.totalCompleted || 0;
      if (count >= 20) completionStats.completed20++;
      else if (count >= 10) completionStats.completed10to19++;
      else if (count >= 1) completionStats.completed1to9++;
      else completionStats.completed0++;
    });
    
    // 统计作品评分情况
    const workStats = {
      reached20: 0,
      reached10to19: 0,
      reached1to9: 0,
      reached0: 0
    };
    
    for (const work of allWorks.items) {
      const count = work.currentRatingCount || 0;
      if (count >= 20) workStats.reached20++;
      else if (count >= 10) workStats.reached10to19++;
      else if (count >= 1) workStats.reached1to9++;
      else workStats.reached0++;
    }
    
    return {
      totalUsers: allTasks.items.length,
      totalWorks: allWorks.items.length,
      userCompletion: completionStats,
      workRatings: workStats,
      timestamp: new Date()
    };
    
  } catch (error) {
    // console.error('获取系统统计失败:', error);
    throw error;
  }
}

/**
 * 获取所有用户的任务管理数据（管理员专用）- 优化版
 * 包含详细的权重算法信息
 */
export async function getAllUsersTaskManagementData() {
  try {
    // 1. 并行获取所有基础数据
    const [allTaskRecords, allRegistrations, allWorks, allComments] = await Promise.all([
      wixData.query(COLLECTIONS.USER_TASKS).limit(1000).find(),
      wixData.query(COLLECTIONS.REGISTRATIONS).limit(1000).find(),
      wixData.query(COLLECTIONS.WORKS).limit(1000).find(),
      wixData.query(COLLECTIONS.COMMENTS).isEmpty('replyTo').limit(1000).find()
    ]);
    
    // 2. 构建用户高权重映射
    const userQualityMap = {};
    allRegistrations.items.forEach(reg => {
      userQualityMap[reg._owner] = reg.isHighQuality === true;
    });
    
    // 3. 构建作品信息映射
    const worksMap = {};
    allWorks.items.forEach(work => {
      worksMap[work.sequenceId] = work;
    });
    
    // 4. 构建评论映射（按作品分组）
    const commentsMap = {};
    allComments.items.forEach(comment => {
      if (!commentsMap[comment.workNumber]) {
        commentsMap[comment.workNumber] = [];
      }
      commentsMap[comment.workNumber].push(comment);
    });
    
    // 5. 预计算所有涉及作品的权重数据（批量处理）
    const allTaskWorkNumbers = new Set();
    allTaskRecords.items.forEach(record => {
      (record.currentTasks || []).forEach(task => {
        allTaskWorkNumbers.add(task.workNumber);
      });
    });
    
    const workWeightDataMap = {};
    for (const workNumber of allTaskWorkNumbers) {
      const work = worksMap[workNumber];
      if (!work) continue;
      
      const comments = commentsMap[workNumber] || [];
      const validRatings = comments.filter(c => c._owner !== work._owner);
      
      let highWeightSum = 0;
      let highWeightCount = 0;
      let lowWeightSum = 0;
      let lowWeightCount = 0;
      
      for (const comment of validRatings) {
        const isHighQuality = userQualityMap[comment._owner] || false;
        if (isHighQuality) {
          highWeightSum += comment.score;
          highWeightCount++;
        } else {
          lowWeightSum += comment.score;
          lowWeightCount++;
        }
      }
      
      const ratio = lowWeightCount > 0 ? highWeightCount / lowWeightCount : (highWeightCount > 0 ? 999 : 0);
      
      workWeightDataMap[workNumber] = {
        numRatings: validRatings.length,
        highWeightCount: highWeightCount,
        lowWeightCount: lowWeightCount,
        ratio: ratio
      };
    }
    
    // 6. 为每个用户计算任务详情（使用预计算的数据）
    const usersTaskData = [];
    
    for (const taskRecord of allTaskRecords.items) {
      const userId = taskRecord.userId;
      const isHighQuality = userQualityMap[userId] || false;
      const currentTasks = taskRecord.currentTasks || [];
      
      const tasksWithDetails = [];
      for (const task of currentTasks) {
        const workInfo = worksMap[task.workNumber];
        if (!workInfo) continue;
        
        const weightData = workWeightDataMap[task.workNumber] || {
          numRatings: 0,
          highWeightCount: 0,
          lowWeightCount: 0,
          ratio: 0
        };
        
        // 计算基础冷门权重（不含均衡因子）
        const baseWeight = calculateBaseColdnessWeightSync(workInfo);
        
        // 计算均衡因子
        const balanceFactor = calculateBalanceFactor(
          weightData.highWeightCount,
          weightData.lowWeightCount,
          isHighQuality
        );
        
        // 最终权重 = 基础权重 × 均衡因子
        const finalWeight = Math.round(baseWeight * balanceFactor);
        
        tasksWithDetails.push({
          workNumber: task.workNumber,
          workTitle: workInfo.firstName || "未命名作品",
          baseWeight: baseWeight,
          balanceFactor: balanceFactor,
          finalWeight: finalWeight,
          currentRatings: weightData.numRatings,
          highWeightCount: weightData.highWeightCount,
          lowWeightCount: weightData.lowWeightCount,
          ratio: weightData.ratio,
          ratioStatus: getRatioStatus(weightData.ratio),
          daysSinceSubmission: getDaysSinceSubmission(workInfo)
        });
      }
      
      // 获取用户所有评论的作品
      const allUserRatings = await getUserCompletedRatings(userId);
      const completedTasks = taskRecord.completedTasks || [];
      const freeRatings = allUserRatings.filter(workNum => !completedTasks.includes(workNum));
      
      usersTaskData.push({
        userId: userId,
        isHighQuality: isHighQuality,
        currentTasks: tasksWithDetails,
        completedTasks: completedTasks.sort((a, b) => b - a), // 任务完成的作品
        freeRatings: freeRatings.sort((a, b) => b - a),      // 自主评论的作品
        completedCount: taskRecord.totalCompleted || 0,
        targetCompletion: TARGET_USER_COMPLETION,
        lastRefreshTime: taskRecord.lastRefreshTime
      });
    }
    
    // 7. 计算整体统计
    const totalHighQualityUsers = Object.values(userQualityMap).filter(v => v).length;
    const totalLowQualityUsers = allRegistrations.items.length - totalHighQualityUsers;
    
    return {
      users: usersTaskData,
      stats: {
        totalUsers: usersTaskData.length,
        highQualityUsers: totalHighQualityUsers,
        lowQualityUsers: totalLowQualityUsers,
        targetRatio: TARGET_HIGH_LOW_RATIO,
        tolerance: RATIO_TOLERANCE
      }
    };
    
  } catch (error) {
    console.error('获取任务管理数据失败:', error);
    throw error;
  }
}

/**
 * 计算基础冷门权重（不含均衡因子）- 同步版本
 * @param {Object} work - 作品对象
 * @returns {number} 基础权重
 */
function calculateBaseColdnessWeightSync(work) {
  const daysSinceSubmission = getDaysSinceSubmission(work);
  const currentRatings = work.currentRatingCount || 0;
  
  if (currentRatings >= TARGET_RATING_COUNT) {
    return 0;
  }
  
  let expectedRatings = 0;
  if (daysSinceSubmission <= 7) {
    expectedRatings = Math.floor(daysSinceSubmission * 1.43);
  } else if (daysSinceSubmission <= 30) {
    expectedRatings = 10 + Math.floor((daysSinceSubmission - 7) * 0.43);
  } else {
    expectedRatings = TARGET_RATING_COUNT;
  }
  
  const deficit = Math.max(0, expectedRatings - currentRatings);
  const deficitRatio = expectedRatings > 0 ? deficit / expectedRatings : 0;
  const baseWeight = deficitRatio * 60 + 15; // 与主函数保持一致
  
  let urgencyBonus = 0;
  
  // 早期冷启动加成
  if (daysSinceSubmission >= 3 && currentRatings < 2) {
    urgencyBonus = 15;
  }
  if (daysSinceSubmission >= 5 && currentRatings < 5) {
    urgencyBonus = 20;
  }
  
  // 中期关注加成
  if (daysSinceSubmission >= 7 && currentRatings < 10) {
    urgencyBonus = 30;
  }
  if (daysSinceSubmission >= 14 && currentRatings < 15) {
    urgencyBonus = 45;
  }
  
  // 后期紧急加成
  if (daysSinceSubmission >= 21 && currentRatings < 18) {
    urgencyBonus = 65;
  }
  
  // 超期最高优先级
  if (daysSinceSubmission >= 30 && currentRatings < 20) {
    urgencyBonus = 80;
  }
  
  return Math.round(baseWeight + urgencyBonus);
}

/**
 * 获取比例状态描述
 * @param {number} ratio - 高低权重比例（占比形式：高/(高+低)）
 * @returns {string} 状态描述
 */
function getRatioStatus(ratio) {
  // 注意：这里的ratio参数需要是占比（0-1），不是高/低的比值
  // 如果传入的是高/低比值，需要先转换
  let highPercentage = ratio;
  if (ratio > 1) {
    // 可能是高/低比值，转换为占比
    highPercentage = ratio / (ratio + 1);
  }
  
  // 均衡区间：28%-45%
  if (highPercentage >= 0.28 && highPercentage <= 0.45) {
    return '均衡';
  } else if (highPercentage > 0.45) {
    return '高权重过多';
  } else {
    return '高权重不足';
  }
}

/**
 * 强制刷新指定用户的任务（管理员专用）
 * @param {string} userId - 用户ID
 * @returns {Promise<Object>} 刷新结果
 */
export async function forceRefreshUserTasks(userId) {
  try {
    console.log(`\n========== 强制刷新用户任务: ${userId} ==========`);
    
    // 获取用户任务记录
    const taskRecord = await getUserTaskRecord(userId);
    console.log(`原任务列表:`, taskRecord.currentTasks?.map(t => `#${t.workNumber}(${t.weight})`).join(', '));
    
    // 清空当前任务，强制重新生成
    taskRecord.currentTasks = [];
    taskRecord.lastRefreshTime = new Date();
    
    // 清除用户权重缓存，确保使用最新数据
    if (userId in userQualityCache) {
      delete userQualityCache[userId];
    }
    
    console.log(`开始生成新任务...`);
    
    // 生成新任务
    const newTasks = await generateUserTasks(userId, taskRecord, 3);
    taskRecord.currentTasks = newTasks;
    
    console.log(`新任务列表:`, newTasks.map(t => `#${t.workNumber}(${t.weight})`).join(', '));
    
    // 保存到数据库
    await wixData.update(COLLECTIONS.USER_TASKS, taskRecord);
    console.log(`任务已保存到数据库`);
    console.log(`========== 刷新完成 ==========\n`);
    
    return {
      success: true,
      message: '任务已刷新',
      newTasksCount: newTasks.length,
      newTasks: newTasks
    };
    
  } catch (error) {
    console.error('强制刷新用户任务失败:', error);
    return {
      success: false,
      message: '刷新失败: ' + error.message
    };
  }
}

/**
 * 获取所有作品的权重对比数据（管理员专用）
 * 显示每个作品对于高权重和低权重用户的权重差异
 */
export async function getAllWorksWeightComparison() {
  try {
    // 1. 并行获取所有基础数据
    const [allWorks, allComments, allRegistrations] = await Promise.all([
      wixData.query(COLLECTIONS.WORKS).ne('isDq', true).limit(1000).find(),
      wixData.query(COLLECTIONS.COMMENTS).isEmpty('replyTo').limit(1000).find(),
      wixData.query(COLLECTIONS.REGISTRATIONS).limit(1000).find()
    ]);
    
    // 2. 构建用户权重映射
    const userQualityMap = {};
    allRegistrations.items.forEach(reg => {
      userQualityMap[reg._owner] = reg.isHighQuality === true;
    });
    
    // 3. 构建评论映射
    const commentsMap = {};
    allComments.items.forEach(comment => {
      if (!commentsMap[comment.workNumber]) {
        commentsMap[comment.workNumber] = [];
      }
      commentsMap[comment.workNumber].push(comment);
    });
    
    // 4. 计算每个作品的权重数据
    const worksWeightData = [];
    
    for (const work of allWorks.items) {
      const comments = commentsMap[work.sequenceId] || [];
      const validRatings = comments.filter(c => c._owner !== work._owner);
      
      // 统计高低权重评分
      let highWeightCount = 0;
      let lowWeightCount = 0;
      
      for (const comment of validRatings) {
        if (userQualityMap[comment._owner]) {
          highWeightCount++;
        } else {
          lowWeightCount++;
        }
      }
      
      const ratio = lowWeightCount > 0 ? highWeightCount / lowWeightCount : (highWeightCount > 0 ? 999 : 0);
      
      // 计算基础冷门权重
      const baseWeight = calculateBaseColdnessWeightSync(work);
      
      // 计算对于高权重用户的均衡因子和最终权重
      const balanceFactorHigh = calculateBalanceFactor(highWeightCount, lowWeightCount, true);
      const finalWeightHigh = Math.round(baseWeight * balanceFactorHigh);
      
      // 计算对于低权重用户的均衡因子和最终权重
      const balanceFactorLow = calculateBalanceFactor(highWeightCount, lowWeightCount, false);
      const finalWeightLow = Math.round(baseWeight * balanceFactorLow);
      
      worksWeightData.push({
        sequenceId: work.sequenceId,
        title: work.firstName || "未命名作品",
        currentRatings: validRatings.length,
        highWeightCount: highWeightCount,
        lowWeightCount: lowWeightCount,
        ratio: ratio,
        ratioStatus: getRatioStatus(ratio),
        daysSinceSubmission: getDaysSinceSubmission(work),
        baseWeight: baseWeight,
        // 对于高权重用户
        balanceFactorHigh: balanceFactorHigh,
        finalWeightHigh: finalWeightHigh,
        // 对于低权重用户
        balanceFactorLow: balanceFactorLow,
        finalWeightLow: finalWeightLow,
        // 权重差异
        weightDifference: finalWeightHigh - finalWeightLow
      });
    }
    
    // 5. 按作品序号排序
    worksWeightData.sort((a, b) => a.sequenceId - b.sequenceId);
    
    return {
      works: worksWeightData,
      config: {
        targetRatio: TARGET_HIGH_LOW_RATIO,
        tolerance: RATIO_TOLERANCE,
        balanceAdjustment: BALANCE_FACTOR_ADJUSTMENT
      }
    };
    
  } catch (error) {
    console.error('获取作品权重对比数据失败:', error);
    throw error;
  }
}


