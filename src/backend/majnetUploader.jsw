/**
 * Majnet ä¸Šä¼ æ¨¡å—
 * è‡ªåŠ¨å°†wixæ•°æ®é›†ä¸­çš„è°±é¢ä¸Šä¼ åˆ°majnetå¹³å°
 */

import { fetch } from "wix-fetch";
import { mediaManager } from "wix-media-backend";
import { getFileDownloadUrlAndContent } from "backend/mediaManagement.jsw";
import {
  logInfo,
  logError,
  logWarning,
  safeExecute,
} from "backend/errorHandler";

// Majnet APIé…ç½®
const MAJNET_CONFIG = {
  LOGIN_URL: "https://majdata.net/api3/api/account/Login",
  UPLOAD_URL: "https://majdata.net/api3/api/maichart/upload",
  USERNAME: "mmfc_bot",
  FALLBACK_DESIGNER: "mmfc",
  UPLOAD_DELAY: 2000, // ä¸Šä¼ é—´éš”ï¼ˆæ¯«ç§’ï¼‰
  
  // é‡è¯•å’Œè¶…æ—¶é…ç½®
  MAX_RETRIES: 3, // æœ€å¤§é‡è¯•æ¬¡æ•°
  BASE_TIMEOUT: 30000, // åŸºç¡€è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
  MAX_TIMEOUT: 120000, // æœ€å¤§è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
  RETRY_DELAY: 2000, // é‡è¯•ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  CONNECTION_RETRY_DELAY: 3000, // è¿æ¥é”™è¯¯é‡è¯•ç­‰å¾…æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  
  // æ¨¡æ‹ŸçœŸå®æµè§ˆå™¨çš„ User-Agentï¼Œé¿å…è§¦å‘ Cloudflare æ£€æŸ¥
  USER_AGENT: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
};

// å…¨å±€ä¼šè¯çŠ¶æ€
let sessionCookies = null;
let lastLoginTime = null;
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30åˆ†é’Ÿ

/**
 * é¢„è®¡ç®—çš„å¯†ç MD5å€¼
 * "redwhite7687" çš„ MD5 = "0c95eabfbdfdb54a9fd6aac5dccdcc0f"
 */
const PASSWORD_MD5 = "0c95eabfbdfdb54a9fd6aac5dccdcc0f";

/**
 * è·å–é€šç”¨è¯·æ±‚å¤´ï¼ˆæ¨¡æ‹ŸçœŸå®æµè§ˆå™¨ï¼‰
 * é¿å…è§¦å‘ Cloudflare çš„æµè§ˆå™¨å®Œæ•´æ€§æ£€æŸ¥
 */
function getCommonHeaders() {
  return {
    'User-Agent': MAJNET_CONFIG.USER_AGENT,
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Accept-Encoding': 'gzip, deflate, br',
    'Connection': 'keep-alive',
    'Cache-Control': 'max-age=0',
    'Referer': 'https://majdata.net/',
    'Sec-Fetch-Dest': 'document',
    'Sec-Fetch-Mode': 'navigate',
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-User': '?1',
  };
}

/**
 * ç™»å½•Majnetï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
 */
async function loginToMajnet() {
  return safeExecute(
    async () => {
      // æ£€æŸ¥ä¼šè¯æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
      if (
        sessionCookies &&
        lastLoginTime &&
        Date.now() - lastLoginTime < SESSION_TIMEOUT
      ) {
        logInfo("loginToMajnet", "ä½¿ç”¨ç°æœ‰ä¼šè¯");
        return { success: true, message: "ä½¿ç”¨ç¼“å­˜ä¼šè¯" };
      }

      // å¸¦é‡è¯•çš„ç™»å½•
      let lastError = null;
      for (let attempt = 1; attempt <= MAJNET_CONFIG.MAX_RETRIES; attempt++) {
        try {
          logInfo("loginToMajnet", `ç™»å½•å°è¯• ${attempt}/${MAJNET_CONFIG.MAX_RETRIES}`);
          
          const response = await fetch(MAJNET_CONFIG.LOGIN_URL, {
            method: "POST",
            headers: {
              ...getCommonHeaders(),
              "Content-Type": "application/x-www-form-urlencoded",
            },
            body: `username=${MAJNET_CONFIG.USERNAME}&password=${PASSWORD_MD5}`,
          });

          if (response.status === 200) {
            // ä¿å­˜ä¼šè¯cookies
            const cookies = response.headers.get("set-cookie");
            if (cookies) {
              sessionCookies = cookies;
              lastLoginTime = Date.now();
            }

            const retryInfo = attempt > 1 ? ` (é‡è¯• ${attempt}/${MAJNET_CONFIG.MAX_RETRIES} æ¬¡åæˆåŠŸ)` : "";
            logInfo("loginToMajnet", `âœ… ç™»å½•æˆåŠŸ${retryInfo}`);
            return {
              success: true,
              message: `ç™»å½•æˆåŠŸ${retryInfo}`,
              statusCode: response.status,
            };
          }

          // æœåŠ¡å™¨æ‹’ç»ï¼Œä¸é‡è¯•
          if (response.status >= 400 && response.status < 600) {
            sessionCookies = null;
            lastLoginTime = null;
            const errorText = await response.text();
            logError("loginToMajnet", `âŒ æœåŠ¡å™¨æ‹’ç»ç™»å½•: ${response.status} - ${errorText.substring(0, 200)}`);
            return {
              success: false,
              message: `ç™»å½•å¤±è´¥: ${response.status}`,
              statusCode: response.status,
              error: errorText,
            };
          }

          lastError = `çŠ¶æ€ç  ${response.status}`;
        } catch (error) {
          lastError = error.message;
          logWarning("loginToMajnet", `å°è¯• ${attempt} å¤±è´¥: ${error.message}`);
          
          // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯•
          if (attempt < MAJNET_CONFIG.MAX_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, MAJNET_CONFIG.CONNECTION_RETRY_DELAY));
          }
        }
      }

      // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
      sessionCookies = null;
      lastLoginTime = null;
      logError("loginToMajnet", `âŒ ç™»å½•å¤±è´¥ (å·²é‡è¯• ${MAJNET_CONFIG.MAX_RETRIES} æ¬¡): ${lastError}`);
      
      return {
        success: false,
        message: `ç™»å½•å¤±è´¥ (å·²é‡è¯• ${MAJNET_CONFIG.MAX_RETRIES} æ¬¡)`,
        error: lastError,
      };
    },
    "loginToMajnet",
    { success: false, message: "ç™»å½•å¼‚å¸¸" }
  );
}

/**
 * ç¡®ä¿maidata.txtä¸­æœ‰designerå­—æ®µ
 */
function ensureDesigner(maidataContent) {
  if (!maidataContent || typeof maidataContent !== "string") {
    logError("ensureDesigner", "maidataå†…å®¹æ— æ•ˆ");
    return `&des=${MAJNET_CONFIG.FALLBACK_DESIGNER}\n`;
  }

  const lines = maidataContent.split("\n");
  let hasDesigner = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line.toLowerCase().startsWith("&des=")) {
      const value = line.split("=")[1]?.trim();
      if (!value) {
        lines[i] = `&des=${MAJNET_CONFIG.FALLBACK_DESIGNER}`;
        logInfo("ensureDesigner", "è¡¥å……äº†ç©ºçš„designerå­—æ®µ");
      }
      hasDesigner = true;
      break;
    }
  }

  if (!hasDesigner) {
    // åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ designerï¼ˆæ›´å®‰å…¨ï¼‰
    lines.unshift(`&des=${MAJNET_CONFIG.FALLBACK_DESIGNER}`);
    logInfo("ensureDesigner", "æ·»åŠ äº†ç¼ºå¤±çš„designerå­—æ®µ");
  }

  return lines.join("\n");
}

/**
 * è·å–æ–‡ä»¶çš„äºŒè¿›åˆ¶å†…å®¹
 */
async function getFileBinary(fileUrl) {
  return safeExecute(
    async () => {
      const downloadUrl = await mediaManager.getDownloadUrl(fileUrl);
      const response = await fetch(downloadUrl);

      if (!response.ok) {
        throw new Error(`è·å–æ–‡ä»¶å¤±è´¥: ${response.status}`);
      }

      // Wix Velo ä½¿ç”¨ buffer() è€Œä¸æ˜¯ arrayBuffer()
      const buffer = await response.buffer();
      return {
        buffer: buffer,
        contentType: response.headers.get("content-type"),
      };
    },
    "getFileBinary",
    null
  );
}

/**
 * è®¡ç®—æ–‡ä»¶æ€»å¤§å°ï¼ˆå­—èŠ‚ï¼‰
 */
function calculateTotalSize(files) {
  let totalSize = 0;
  for (const file of files) {
    if (typeof file.content === "string") {
      totalSize += Buffer.byteLength(file.content, "utf8");
    } else if (Buffer.isBuffer(file.content)) {
      totalSize += file.content.length;
    }
  }
  return totalSize;
}

/**
 * æ ¹æ®æ–‡ä»¶å¤§å°è®¡ç®—åŠ¨æ€è¶…æ—¶æ—¶é—´
 * @param {number} totalSizeBytes - æ–‡ä»¶æ€»å¤§å°ï¼ˆå­—èŠ‚ï¼‰
 * @returns {number} è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
 */
function calculateDynamicTimeout(totalSizeBytes) {
  const sizeMB = totalSizeBytes / (1024 * 1024);
  // æ¯10MBå¢åŠ 15ç§’
  const extraTimeout = Math.floor(sizeMB / 10) * 15000;
  const calculatedTimeout = MAJNET_CONFIG.BASE_TIMEOUT + extraTimeout;
  
  // é™åˆ¶åœ¨æœ€å¤§è¶…æ—¶èŒƒå›´å†…
  const finalTimeout = Math.min(calculatedTimeout, MAJNET_CONFIG.MAX_TIMEOUT);
  
  logInfo(
    "calculateDynamicTimeout",
    `æ–‡ä»¶å¤§å°: ${sizeMB.toFixed(1)}MB, è¶…æ—¶: ${finalTimeout / 1000}ç§’`
  );
  
  return finalTimeout;
}

/**
 * æ„å»ºmultipart/form-dataè¯·æ±‚ä½“
 */
function buildMultipartFormData(files) {
  const boundary =
    "----WebKitFormBoundary" + Math.random().toString(36).substr(2);
  const parts = [];

  for (const file of files) {
    const { filename, content, contentType } = file;

    // æ„å»ºæ–‡ä»¶å¤´éƒ¨
    let header = "";
    header += `--${boundary}\r\n`;
    header += `Content-Disposition: form-data; name="formfiles"; filename="${filename}"\r\n`;
    header += `Content-Type: ${contentType}\r\n\r\n`;

    // æ·»åŠ å¤´éƒ¨ï¼ˆå­—ç¬¦ä¸²è½¬Bufferï¼‰
    parts.push(Buffer.from(header, "utf8"));

    // æ·»åŠ å†…å®¹ï¼ˆå¯èƒ½æ˜¯å­—ç¬¦ä¸²æˆ–Bufferï¼‰
    if (typeof content === "string") {
      parts.push(Buffer.from(content, "utf8"));
    } else {
      parts.push(content); // å·²ç»æ˜¯Buffer
    }

    // æ·»åŠ åˆ†éš”ç¬¦
    parts.push(Buffer.from("\r\n", "utf8"));
  }

  // æ·»åŠ ç»“æŸè¾¹ç•Œ
  parts.push(Buffer.from(`--${boundary}--\r\n`, "utf8"));

  // åˆå¹¶æ‰€æœ‰Buffer
  const body = Buffer.concat(parts);

  return {
    body: body,
    boundary,
    totalSize: body.length,
  };
}

/**
 * ä¸Šä¼ è°±é¢åˆ°Majnet
 * @param {Object} chartData - åŒ…å«æ–‡ä»¶URLçš„è°±é¢æ•°æ®
 * @returns {Promise<Object>} ä¸Šä¼ ç»“æœ
 */
export async function uploadChartToMajnet(chartData) {
  return safeExecute(
    async () => {
      const {
        maidataUrl, // maidata.txtçš„wix URL
        trackUrl, // track.mp3çš„wix URL
        bgUrl, // bg.png/jpgçš„wix URL
        bgVideoUrl, // èƒŒæ™¯è§†é¢‘URLï¼ˆå¯é€‰ï¼‰
        chartTitle, // è°±é¢æ ‡é¢˜ï¼ˆç”¨äºæ—¥å¿—ï¼‰
      } = chartData;

      logInfo("uploadChartToMajnet", `å¼€å§‹ä¸Šä¼ è°±é¢: ${chartTitle || "æœªå‘½å"}`);

      // 1. ç¡®ä¿å·²ç™»å½•
      const loginResult = await loginToMajnet();
      if (!loginResult.success) {
        return {
          success: false,
          message: "ç™»å½•å¤±è´¥",
          error: loginResult.message,
        };
      }

      // 2. è·å–æ‰€æœ‰æ–‡ä»¶
      const files = [];

      try {
        // 2.1 è·å–maidata.txt
        if (!maidataUrl) {
          throw new Error("ç¼ºå°‘maidata.txtæ–‡ä»¶");
        }
        logInfo("uploadChartToMajnet", "æ­£åœ¨è·å–maidata.txt...");
        const maidataResult = await getFileDownloadUrlAndContent(maidataUrl);
        if (!maidataResult || !maidataResult.fileContent) {
          throw new Error("maidata.txtå†…å®¹ä¸ºç©º");
        }
        const maidataContent = ensureDesigner(maidataResult.fileContent);
        files.push({
          filename: "maidata.txt",
          content: maidataContent,
          contentType: "text/plain",
        });
        logInfo("uploadChartToMajnet", "maidata.txtå‡†å¤‡å®Œæˆ");

        // 2.2 è·å–èƒŒæ™¯å›¾
        if (!bgUrl) {
          throw new Error("ç¼ºå°‘èƒŒæ™¯å›¾æ–‡ä»¶");
        }
        logInfo("uploadChartToMajnet", "æ­£åœ¨è·å–èƒŒæ™¯å›¾...");
        const bgBinary = await getFileBinary(bgUrl);
        if (!bgBinary || !bgBinary.buffer) {
          throw new Error("èƒŒæ™¯å›¾è·å–å¤±è´¥");
        }
        const bgExtension = bgUrl.toLowerCase().includes(".jpg")
          ? "jpg"
          : "png";
        files.push({
          filename: `bg.${bgExtension}`,
          content: bgBinary.buffer,
          contentType: bgBinary.contentType || `image/${bgExtension}`,
        });
        logInfo("uploadChartToMajnet", `èƒŒæ™¯å›¾å‡†å¤‡å®Œæˆ (${bgExtension})`);

        // 2.3 è·å–éŸ³é¢‘æ–‡ä»¶
        if (!trackUrl) {
          throw new Error("ç¼ºå°‘éŸ³é¢‘æ–‡ä»¶");
        }
        logInfo("uploadChartToMajnet", "æ­£åœ¨è·å–éŸ³é¢‘æ–‡ä»¶...");
        const trackBinary = await getFileBinary(trackUrl);
        if (!trackBinary || !trackBinary.buffer) {
          throw new Error("éŸ³é¢‘æ–‡ä»¶è·å–å¤±è´¥");
        }
        files.push({
          filename: "track.mp3",
          content: trackBinary.buffer,
          contentType: trackBinary.contentType || "audio/mpeg",
        });
        logInfo("uploadChartToMajnet", "éŸ³é¢‘æ–‡ä»¶å‡†å¤‡å®Œæˆ");

        // 2.4 è·å–è§†é¢‘ï¼ˆå¦‚æœæœ‰ï¼‰
        if (bgVideoUrl) {
          const videoBinary = await getFileBinary(bgVideoUrl);
          const videoExtension = bgVideoUrl.toLowerCase().includes("pv.mp4")
            ? "pv.mp4"
            : "bg.mp4";
          files.push({
            filename: videoExtension,
            content: videoBinary.buffer,
            contentType: videoBinary.contentType || "video/mp4",
          });
        }
      } catch (error) {
        logError("uploadChartToMajnet", `æ–‡ä»¶å‡†å¤‡å¤±è´¥: ${error.message}`);
        return {
          success: false,
          message: "æ–‡ä»¶å‡†å¤‡å¤±è´¥",
          error: error.message,
        };
      }

      // 3. æ„å»ºå¹¶å‘é€ä¸Šä¼ è¯·æ±‚ï¼ˆå¸¦é‡è¯•ï¼‰
      return await uploadWithRetry(files, chartTitle);
    },
    "uploadChartToMajnet",
    {
      success: false,
      message: "ä¸Šä¼ å¼‚å¸¸",
    }
  );
}

/**
 * å¸¦é‡è¯•æœºåˆ¶çš„ä¸Šä¼ å‡½æ•°
 * @param {Array} files - æ–‡ä»¶æ•°ç»„
 * @param {string} chartTitle - è°±é¢æ ‡é¢˜
 * @returns {Promise<Object>} ä¸Šä¼ ç»“æœ
 */
async function uploadWithRetry(files, chartTitle) {
  return safeExecute(
    async () => {
      logInfo("uploadWithRetry", `å‡†å¤‡ä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶...`);
      
      // æ„å»ºè¯·æ±‚ä½“
      const formData = buildMultipartFormData(files);
      const totalSizeMB = (formData.totalSize / (1024 * 1024)).toFixed(1);
      logInfo(
        "uploadWithRetry",
        `è¯·æ±‚ä½“æ„å»ºå®Œæˆï¼Œå¤§å°: ${totalSizeMB}MB`
      );

      // è®¡ç®—åŠ¨æ€è¶…æ—¶
      let currentTimeout = calculateDynamicTimeout(formData.totalSize);
      
      // å¼€å§‹é‡è¯•å¾ªç¯
      let lastError = null;
      let lastErrorType = null;
      
      for (let attempt = 1; attempt <= MAJNET_CONFIG.MAX_RETRIES; attempt++) {
        try {
          logInfo(
            "uploadWithRetry",
            `å°è¯• ${attempt}/${MAJNET_CONFIG.MAX_RETRIES}: ${chartTitle} (è¶…æ—¶: ${currentTimeout / 1000}ç§’)`
          );

          const headers = {
            ...getCommonHeaders(),
            "Content-Type": `multipart/form-data; boundary=${formData.boundary}`,
          };

          if (sessionCookies) {
            headers["Cookie"] = sessionCookies;
          }

          // å‘é€ä¸Šä¼ è¯·æ±‚
          const response = await fetch(MAJNET_CONFIG.UPLOAD_URL, {
            method: "POST",
            headers,
            body: formData.body,
          });

          const responseText = await response.text();
          logInfo("uploadWithRetry", `æ”¶åˆ°å“åº”ï¼ŒçŠ¶æ€ç : ${response.status}`);

          // æˆåŠŸ
          if (response.status === 200) {
            const retryInfo = attempt > 1 ? ` (é‡è¯• ${attempt}/${MAJNET_CONFIG.MAX_RETRIES} æ¬¡åæˆåŠŸ)` : "";
            logInfo(
              "uploadWithRetry",
              `âœ… ä¸Šä¼ æˆåŠŸ: ${chartTitle}${retryInfo} - å“åº”: ${responseText.substring(0, 200)}`
            );
            return {
              success: true,
              message: `ä¸Šä¼ æˆåŠŸ${retryInfo}`,
              statusCode: response.status,
              response: responseText,
            };
          }

          // æœåŠ¡å™¨æ‹’ç»ï¼ˆ4xx/5xxï¼‰ï¼Œä¸é‡è¯•
          if (response.status >= 400 && response.status < 600) {
            const errorMsg = `çŠ¶æ€ç ${response.status} | å“åº”: ${responseText.substring(0, 300)} | ä½œå“: ${chartTitle} | æ–‡ä»¶æ•°: ${files.length}`;
            logError("uploadWithRetry", `âŒ æœåŠ¡å™¨æ‹’ç»: ${errorMsg}`);

            // å¦‚æœæ˜¯400é”™è¯¯ï¼Œé¢å¤–è®°å½•è¯·æ±‚è¯¦æƒ…
            if (response.status === 400) {
              const fileList = files.map((f) => f.filename).join(", ");
              logError(
                "uploadWithRetry - 400è¯¦æƒ…",
                `æ–‡ä»¶åˆ—è¡¨: [${fileList}] | å¤§å°: ${totalSizeMB}MB`
              );
            }

            return {
              success: false,
              message: `âŒ æœåŠ¡å™¨æ‹’ç»ï¼ŒçŠ¶æ€ç  ${response.status}`,
              statusCode: response.status,
              error: responseText,
              details: errorMsg,
            };
          }

          // å…¶ä»–çŠ¶æ€ç ï¼Œè®°å½•å¹¶é‡è¯•
          lastError = `çŠ¶æ€ç  ${response.status}`;
          lastErrorType = "http_error";
          
        } catch (error) {
          // åˆ¤æ–­é”™è¯¯ç±»å‹
          const errorMsg = error.message || String(error);
          
          if (errorMsg.includes("timeout") || errorMsg.includes("ETIMEDOUT")) {
            lastErrorType = "timeout";
            lastError = `è¯·æ±‚è¶…è¿‡ ${currentTimeout / 1000} ç§’æœªå“åº”`;
            logWarning(
              "uploadWithRetry",
              `â±ï¸ è¶…æ—¶: ${chartTitle} - å°è¯• ${attempt}/${MAJNET_CONFIG.MAX_RETRIES}`
            );
            
            // è¶…æ—¶åå¢åŠ ä¸‹æ¬¡çš„è¶…æ—¶æ—¶é—´
            if (attempt < MAJNET_CONFIG.MAX_RETRIES) {
              currentTimeout = Math.min(currentTimeout * 1.5, MAJNET_CONFIG.MAX_TIMEOUT);
              await new Promise(resolve => setTimeout(resolve, MAJNET_CONFIG.RETRY_DELAY));
            }
          } else if (
            errorMsg.includes("ECONNREFUSED") ||
            errorMsg.includes("ENOTFOUND") ||
            errorMsg.includes("ECONNRESET") ||
            errorMsg.includes("connect")
          ) {
            lastErrorType = "connection";
            lastError = "æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨";
            logWarning(
              "uploadWithRetry",
              `ğŸ”Œ è¿æ¥é”™è¯¯: ${chartTitle} - å°è¯• ${attempt}/${MAJNET_CONFIG.MAX_RETRIES}`
            );
            
            // è¿æ¥é”™è¯¯ç­‰å¾…æ›´é•¿æ—¶é—´
            if (attempt < MAJNET_CONFIG.MAX_RETRIES) {
              await new Promise(resolve => setTimeout(resolve, MAJNET_CONFIG.CONNECTION_RETRY_DELAY));
            }
          } else {
            // æœªçŸ¥é”™è¯¯ï¼Œä¸é‡è¯•
            lastErrorType = "unknown";
            lastError = errorMsg;
            logError("uploadWithRetry", `âŒ æœªçŸ¥é”™è¯¯: ${errorMsg}`);
            break;
          }
        }
      }

      // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
      if (lastErrorType === "timeout") {
        return {
          success: false,
          message: `âŒ ç½‘ç»œè¶…æ—¶: ${lastError} (å·²é‡è¯• ${MAJNET_CONFIG.MAX_RETRIES} æ¬¡)`,
          error: lastError,
        };
      } else if (lastErrorType === "connection") {
        return {
          success: false,
          message: `âŒ è¿æ¥é”™è¯¯: ${lastError} (å·²é‡è¯• ${MAJNET_CONFIG.MAX_RETRIES} æ¬¡)`,
          error: lastError,
        };
      } else {
        return {
          success: false,
          message: `âŒ ä¸Šä¼ å¤±è´¥: ${lastError}`,
          error: lastError,
        };
      }
    },
    "uploadWithRetry",
    {
      success: false,
      message: "ä¸Šä¼ å¼‚å¸¸",
    }
  );
}

/**
 * ä»wixæ•°æ®é›†é¡¹ä¸Šä¼ åˆ°Majnet
 * @param {Object} contestItem - enterContest034æ•°æ®é›†é¡¹
 * @returns {Promise<Object>} ä¸Šä¼ ç»“æœ
 */
export async function uploadContestItemToMajnet(contestItem) {
  return safeExecute(
    async () => {
      // æ˜ å°„å­—æ®µåï¼ˆæ ¹æ®http-functions.jsä¸­çš„å­—æ®µæ˜ å°„ï¼‰
      const chartData = {
        maidataUrl: contestItem.inVideoçš„è¤‡æœ¬, // maidata.txt
        trackUrl: contestItem.maidataçš„è¤‡æœ¬, // track.mp3
        bgUrl: contestItem.trackçš„è¤‡æœ¬, // bg.png/jpg
        bgVideoUrl: contestItem.ä¸Šå‚³æª”æ¡ˆæ¬„, // èƒŒæ™¯è§†é¢‘
        chartTitle: contestItem.firstName, // ä½œå“æ ‡é¢˜
      };

      // è®°å½•å­—æ®µæ˜ å°„æƒ…å†µ
      logInfo(
        "uploadContestItemToMajnet",
        `å­—æ®µæ˜ å°„: maidata=${!!chartData.maidataUrl}, track=${!!chartData.trackUrl}, bg=${!!chartData.bgUrl}, video=${!!chartData.bgVideoUrl}, title=${
          chartData.chartTitle
        }`
      );

      return await uploadChartToMajnet(chartData);
    },
    "uploadContestItemToMajnet",
    {
      success: false,
      message: "ä¸Šä¼ å¤±è´¥",
    }
  );
}

/**
 * æ‰¹é‡ä¸Šä¼ å¤šä¸ªè°±é¢ï¼ˆå¸¦å»¶è¿Ÿï¼‰
 * @param {Array} contestItems - æ•°æ®é›†é¡¹æ•°ç»„
 * @returns {Promise<Array>} ä¸Šä¼ ç»“æœæ•°ç»„
 */
export async function batchUploadToMajnet(contestItems) {
  return safeExecute(
    async () => {
      const results = [];

      for (let i = 0; i < contestItems.length; i++) {
        const item = contestItems[i];

        logInfo(
          "batchUploadToMajnet",
          `ä¸Šä¼ è¿›åº¦: ${i + 1}/${contestItems.length}`
        );

        const result = await uploadContestItemToMajnet(item);
        results.push({
          ...result,
          itemId: item._id,
          chartTitle: item.firstName,
        });

        // ä¸Šä¼ é—´éš”å»¶è¿Ÿ
        if (i < contestItems.length - 1 && MAJNET_CONFIG.UPLOAD_DELAY > 0) {
          await new Promise((resolve) =>
            setTimeout(resolve, MAJNET_CONFIG.UPLOAD_DELAY)
          );
        }
      }

      const successCount = results.filter((r) => r.success).length;
      logInfo(
        "batchUploadToMajnet",
        `æ‰¹é‡ä¸Šä¼ å®Œæˆ: ${successCount}/${contestItems.length} æˆåŠŸ`
      );

      return results;
    },
    "batchUploadToMajnet",
    []
  );
}
