# 动态评分任务分配系统设计方案

## 背景分析

在当前的maimai月赛系统中，存在以下核心挑战：

1. **滚动提交制度**：选手可在2个月赛程内任意时间提交作品
2. **动态参与环境**：前期作品数量少，后期作品数量多，每个作品的曝光时间不等
3. **评分目标**：每个选手至少评价20个谱面，每个作品获得20个左右评分
4. **公平性要求**：确保所有作品都能获得相对均匀的评分机会

## 核心设计理念

### 1. 时间窗口平衡策略

基于作品提交时间设计多层次的评分保障机制：

- **即时保障窗口**（3天）：新提交作品在3天内至少获得5个评分
- **短期平衡窗口**（7天）：作品在一周内至少获得10个评分  
- **中期稳定窗口**（14天）：作品在两周内至少获得15个评分
- **长期目标窗口**（30天）：作品在一个月内达到20个评分目标

### 2. 动态任务分配算法

系统根据实时状态为每个用户生成个性化的评分任务列表：

```javascript
// 任务优先级算法示例
function calculateTaskPriority(work, currentTime) {
  const daysSinceSubmission = (currentTime - work.submissionTime) / (1000 * 60 * 60 * 24);
  const currentRatingCount = work.ratingCount || 0;
  
  // 评分不足的紧急程度
  const ratingDeficit = Math.max(0, getExpectedRatings(daysSinceSubmission) - currentRatingCount);
  
  // 时间衰减因子
  const timeDecay = Math.exp(-daysSinceSubmission / 14); // 14天半衰期
  
  return ratingDeficit * timeDecay;
}
```

## 详细实施方案

### 第一阶段：数据结构设计

#### 评分任务表（RatingTasks）
```
{
  _id: "任务ID",
  userId: "用户ID", 
  workNumber: "作品序号",
  taskType: "mandatory|optional|urgent",
  assignedDate: "分配日期",
  status: "pending|completed|expired",
  priority: "优先级分数"
}
```

#### 评分统计表（RatingStats）
```
{
  workNumber: "作品序号",
  currentRatingCount: "当前评分数",
  targetRatingCount: "目标评分数", 
  lastUpdated: "最后更新时间",
  ratingVelocity: "评分速度（每日新增评分数）"
}
```

### 第二阶段：核心算法实现

#### 1. 智能任务生成器

```javascript
async function generateUserTasks(userId) {
  const userHistory = await getUserRatingHistory(userId);
  const remainingQuota = Math.max(0, 20 - userHistory.length);
  
  if (remainingQuota === 0) return [];
  
  // 获取候选作品（排除用户自己的作品和已评分作品）
  const candidateWorks = await getCandidateWorks(userId, userHistory);
  
  // 按优先级排序
  const prioritizedWorks = candidateWorks
    .map(work => ({
      ...work,
      priority: calculateTaskPriority(work, new Date())
    }))
    .sort((a, b) => b.priority - a.priority);
  
  // 分配任务
  return prioritizedWorks.slice(0, Math.min(remainingQuota, 10));
}
```

#### 2. 动态平衡调节器

系统每日运行平衡算法，识别评分不足的作品并提高其任务分配优先级：

```javascript
async function rebalanceRatingDistribution() {
  const allWorks = await getAllActiveWorks();
  
  for (const work of allWorks) {
    const daysSinceSubmission = getDaysSinceSubmission(work);
    const expectedRatings = getExpectedRatingsByDay(daysSinceSubmission);
    const actualRatings = await getWorkRatingCount(work.sequenceId);
    
    if (actualRatings < expectedRatings * 0.8) { // 低于期望的80%
      await boostWorkPriority(work.sequenceId);
    }
  }
}
```

### 第三阶段：时间窗口管理

#### 评分期望曲线设计

根据作品提交时间，设计合理的评分累积期望：

- 第1-3天：线性增长至5个评分
- 第4-7天：增长至10个评分  
- 第8-14天：增长至15个评分
- 第15-30天：达到20个评分
- 30天后：维持在20个评分以上

#### 窗口监控机制

```javascript
function getExpectedRatingsByDay(days) {
  if (days <= 3) return Math.floor(days * 5/3);
  if (days <= 7) return 5 + Math.floor((days-3) * 5/4);
  if (days <= 14) return 10 + Math.floor((days-7) * 5/7);
  if (days <= 30) return 15 + Math.floor((days-14) * 5/16);
  return 20;
}
```

### 第四阶段：用户任务管理

#### 任务分配策略

每个用户维护一个动态任务池：
- **活跃任务池**：3-5个高优先级任务
- **候补任务池**：5-10个备选任务
- **完成历史**：已完成的评分记录

#### 任务更新机制

- 用户完成一个评分后，自动从候补池补充新任务
- 每日系统维护时重新计算任务优先级
- 过期任务（分配后7天未完成）自动回收

## 系统运行流程

### 日常运行周期

1. **每日凌晨02:00**：
   - 运行平衡算法，识别评分不足的作品
   - 为所有用户重新生成/更新任务列表
   - 清理过期任务，回收未完成的分配

2. **用户提交评分时**：
   - 标记对应任务为已完成
   - 检查用户任务池，必要时补充新任务
   - 更新作品评分统计

3. **新作品提交时**：
   - 立即为该作品生成初始任务分配
   - 优先分配给任务池较空的活跃用户

### 异常处理机制

#### 评分不足预警
- 作品提交后3天内评分不足3个：提升至紧急优先级
- 作品提交后7天内评分不足8个：大幅提升分配权重
- 作品提交后14天内评分不足12个：强制分配给活跃用户

#### 用户完成度监控
- 赛程过半时，统计用户完成进度
- 对进度严重滞后的用户增加任务分配频率
- 临近赛程结束时，优先为未完成用户分配易评分作品

## 技术实现要点

### 1. 数据库设计
- 使用复合索引优化查询性能：`(userId, status)`, `(workNumber, priority)`
- 定期清理历史数据，避免数据表过大影响性能

### 2. 算法优化
- 缓存用户评分历史，减少重复查询
- 批量处理任务分配，提高系统效率
- 使用概率分配避免任务分配过于集中

### 3. 系统监控
- 记录关键指标：平均评分数、评分分布标准差、用户完成率
- 设置告警机制：评分严重不均时自动调整算法参数

## 任务机制详细执行方案

### 优先级计算的数学模型

#### 1. 基础优先级公式

```javascript
function calculateBasePriority(work, currentTime) {
  const T = getDaysSinceSubmission(work, currentTime);        // 时间因子
  const R_actual = work.currentRatingCount || 0;             // 实际评分数
  const R_expected = getExpectedRatingsByDay(T);             // 期望评分数
  const deficit = Math.max(0, R_expected - R_actual);        // 评分缺口
  
  // 时间衰减函数：防止老作品无限占用资源
  const timeDecay = Math.exp(-T / 14);                       // 14天半衰期
  
  // 紧急程度函数：评分缺口越大，优先级越高
  const urgencyFactor = Math.pow(deficit / R_expected, 1.5); // 非线性增长
  
  return deficit * timeDecay * urgencyFactor;
}
```

#### 2. 动态权重调整

系统根据不同阶段动态调整权重参数：

**赛程前期（0-20天）**：
- 时间权重：0.7（重视新作品）
- 缺口权重：0.3
- 目标：快速为新作品建立基础评分

**赛程中期（21-40天）**：
- 时间权重：0.5（平衡新老作品）
- 缺口权重：0.5
- 目标：维持评分分布均衡

**赛程后期（41-60天）**：
- 时间权重：0.3（重视评分完成度）
- 缺口权重：0.7
- 目标：确保所有作品达到评分目标

#### 3. 用户均衡性因子

```javascript
function applyUserBalancing(basePriority, userId, work) {
  let balancedPriority = basePriority;
  
  // 用户任务负载均衡：避免某些用户任务过多
  const userCurrentLoad = await getUserCurrentTaskLoad(userId);
  const avgUserLoad = await getAverageUserTaskLoad();
  const loadBalanceFactor = avgUserLoad / Math.max(userCurrentLoad, 1);
  
  // 用户参与度调整：鼓励活跃用户承担更多任务
  const userActivity = getUserRecentActivityLevel(userId);
  const activityBonus = Math.min(userActivity * 0.2, 0.5); // 最大50%加成
  
  return balancedPriority * loadBalanceFactor * (1 + activityBonus);
}
```

### 时间处理机制的设计依据

#### 1. 期望评分曲线的数学建模

基于心理学研究和用户行为分析，设计递减式关注度模型：

```javascript
function getExpectedRatingsByDay(days) {
  // 第一阶段（1-3天）：高关注期，线性增长
  if (days <= 3) {
    return Math.floor(days * 1.67); // 每天1.67个评分，3天达到5个
  }
  
  // 第二阶段（4-7天）：稳定期，减缓增长
  if (days <= 7) {
    return 5 + Math.floor((days - 3) * 1.25); // 4天增加5个评分
  }
  
  // 第三阶段（8-14天）：维持期，缓慢增长
  if (days <= 14) {
    return 10 + Math.floor((days - 7) * 0.71); // 7天增加5个评分
  }
  
  // 第四阶段（15-30天）：收尾期，最终达标
  if (days <= 30) {
    return 15 + Math.floor((days - 14) * 0.31); // 16天增加5个评分
  }
  
  return 20; // 30天后维持目标评分
}
```

#### 2. 时间窗口的科学依据

**3天窗口**：基于网络传播学的"黄金72小时"理论
- 新内容在前3天获得最高关注度
- 用户对新作品的好奇心在此期间最强
- 目标：确保新作品获得基础曝光

**7天窗口**：符合用户习惯的周期性行为模式
- 多数用户以周为单位安排评分活动
- 一周内完成的评分通常更具时效性
- 目标：建立作品的初步评价基础

**14天窗口**：工作记忆和长期记忆的转换节点
- 超过两周的作品开始从用户活跃记忆中淡出
- 需要系统主动推送以维持关注度
- 目标：避免作品被"遗忘"

**30天窗口**：赛程节奏和完成度的平衡点
- 为后续新作品留出充足的评分资源
- 确保每个作品都有足够时间积累评分
- 目标：实现评分目标的最终达成

### 任务分配策略的执行细节

#### 1. 多层次任务池管理

```javascript
class UserTaskManager {
  constructor(userId) {
    this.userId = userId;
    this.urgentTasks = [];      // 紧急任务池（0-2个）
    this.activeTasks = [];      // 活跃任务池（3-5个）
    this.reserveTasks = [];     // 候补任务池（5-10个）
    this.completedTasks = [];   // 完成历史
  }
  
  async refreshTaskPools() {
    // 清理过期任务
    this.cleanupExpiredTasks();
    
    // 按优先级重新排序
    await this.reprioritizeTasks();
    
    // 补充任务池
    await this.fillTaskPools();
  }
  
  async fillTaskPools() {
    const targetCounts = {
      urgent: 2,
      active: 5,
      reserve: 10
    };
    
    // 优先填充紧急任务
    if (this.urgentTasks.length < targetCounts.urgent) {
      const urgentCandidates = await this.findUrgentTasks();
      this.urgentTasks.push(...urgentCandidates.slice(0, 
        targetCounts.urgent - this.urgentTasks.length));
    }
    
    // 填充活跃任务池
    if (this.activeTasks.length < targetCounts.active) {
      const activeCandidates = await this.findActiveTasks();
      this.activeTasks.push(...activeCandidates.slice(0,
        targetCounts.active - this.activeTasks.length));
    }
    
    // 填充候补任务池
    if (this.reserveTasks.length < targetCounts.reserve) {
      const reserveCandidates = await this.findReserveTasks();
      this.reserveTasks.push(...reserveCandidates.slice(0,
        targetCounts.reserve - this.reserveTasks.length));
    }
  }
}
```

#### 2. 智能任务轮转机制

```javascript
async function rotateUserTasks(userId) {
  const taskManager = new UserTaskManager(userId);
  
  // 检查任务池状态
  const poolStatus = await taskManager.analyzePoolStatus();
  
  // 动态调整任务类型比例
  const adjustmentStrategy = calculateAdjustmentStrategy(poolStatus);
  
  // 执行任务轮转
  await taskManager.executeRotation(adjustmentStrategy);
}

function calculateAdjustmentStrategy(poolStatus) {
  const strategy = {
    urgentRatio: 0.2,      // 紧急任务比例
    loadBalance: 0.3,      // 负载均衡因子
    timeBalance: 0.3       // 时间平衡因子
  };
  
  // 根据池状态动态调整
  if (poolStatus.urgentDeficit > 0.5) {
    strategy.urgentRatio = 0.4; // 增加紧急任务比例
  }
  
  if (poolStatus.loadImbalance > 0.3) {
    strategy.loadBalance = 0.5; // 增加负载均衡权重
  }
  
  return strategy;
}
```

#### 3. 负载均衡与公平性保障

```javascript
async function ensureFairDistribution() {
  const allUsers = await getActiveUsers();
  const allWorks = await getAllActiveWorks();
  
  // 计算当前分配状态
  const distributionMatrix = await buildDistributionMatrix(allUsers, allWorks);
  
  // 识别分配不均的情况
  const imbalances = analyzeDistributionImbalances(distributionMatrix);
  
  // 执行重新平衡
  for (const imbalance of imbalances) {
    await rebalanceTaskDistribution(imbalance);
  }
}

async function rebalanceTaskDistribution(imbalance) {
  switch (imbalance.type) {
    case 'USER_OVERLOAD':
      // 用户任务过多，分散到其他用户
      await redistributeUserTasks(imbalance.userId);
      break;
      
    case 'WORK_UNDERRATED':
      // 作品评分不足，增加任务分配
      await boostWorkTaskAllocation(imbalance.workNumber);
      break;
      
    case 'ATTENTION_BIAS':
      // 某些作品关注度过低，增加分配权重
      await increaseWorkAttention(imbalance.workNumber);
      break;
  }
}
```

### 异常情况处理的决策逻辑

#### 1. 评分严重不足的应急机制

```javascript
async function handleRatingEmergency(workNumber) {
  const work = await getWorkById(workNumber);
  const daysSinceSubmission = getDaysSinceSubmission(work);
  const currentRatings = await getWorkRatingCount(workNumber);
  const expectedRatings = getExpectedRatingsByDay(daysSinceSubmission);
  
  const deficitRatio = 1 - (currentRatings / expectedRatings);
  
  if (deficitRatio > 0.5) { // 评分不足超过50%
    // 紧急措施：强制分配给活跃用户
    const activeUsers = await getMostActiveUsers(10);
    
    for (const user of activeUsers) {
      await forceAssignTask(user.userId, workNumber, 'EMERGENCY');
    }
    
    // 发送系统通知（如果需要）
    await notifyAdministrators('RATING_EMERGENCY', {
      workNumber,
      deficitRatio,
      currentRatings,
      expectedRatings
    });
  }
}
```

#### 2. 用户完成度监控与干预

```javascript
async function monitorUserProgress() {
  const currentDay = getCurrentContestDay(); // 赛程第几天
  const totalDays = 60; // 总赛程60天
  const progressThreshold = currentDay / totalDays; // 期望完成进度
  
  const allUsers = await getActiveUsers();
  
  for (const user of allUsers) {
    const userProgress = await getUserCompletionRate(user.userId);
    
    if (userProgress < progressThreshold * 0.7) { // 严重滞后
      await applyProgressBoostStrategy(user.userId);
    } else if (userProgress < progressThreshold * 0.9) { // 轻微滞后
      await applyGentleReminderStrategy(user.userId);
    }
  }
}

async function applyProgressBoostStrategy(userId) {
  // 为滞后用户分配更多需要关注的作品
  const underAttentionWorks = await findUnderAttentionWorks(userId);
  
  // 增加任务池大小
  await expandUserTaskPool(userId, underAttentionWorks);
  
  // 提高任务优先级显示
  await boostTaskVisibility(userId);
}
```

### 系统自适应学习机制

#### 1. 用户行为模式分析

```javascript
class UserBehaviorAnalyzer {
  async analyzeUserPatterns(userId) {
    const userHistory = await getUserRatingHistory(userId);
    
    const patterns = {
      activityTimePattern: this.analyzeActivityTimes(userHistory),     // 活跃时间分析
      ratingFrequency: this.analyzeRatingFrequency(userHistory),       // 评分频率分析
      taskCompletionRate: this.analyzeCompletionRate(userHistory),     // 任务完成率
      workSelectionBehavior: this.analyzeSelectionBehavior(userHistory) // 作品选择行为
    };
    
    return patterns;
  }
  
  async optimizeTaskAssignment(userId, patterns) {
    // 根据用户行为模式优化任务分配时机和数量
    const optimizedStrategy = await this.generateOptimizedStrategy(userId, patterns);
    await this.updateUserTaskStrategy(userId, optimizedStrategy);
  }
}
```

#### 2. 系统参数动态优化

```javascript
async function optimizeSystemParameters() {
  const systemMetrics = await collectSystemMetrics();
  
  // 评估当前参数效果
  const effectiveness = evaluateParameterEffectiveness(systemMetrics);
  
  // 基于效果调整参数
  if (effectiveness.ratingDistribution < 0.8) {
    await adjustTimeDecayFactor(0.9); // 减慢时间衰减
  }
  
  if (effectiveness.userEngagement < 0.7) {
    await adjustTaskPoolSizes(1.2); // 增加任务池大小
  }
  
  if (effectiveness.attentionBalance < 0.8) {
    await adjustAttentionBalanceWeights(effectiveness.underAttentionWorks);
  }
  
  if (effectiveness.completionRate < 0.85) {
    await adjustPriorityWeights(effectiveness.bottlenecks);
  }
}
```

## 预期效果

通过该系统实施，预期达到以下目标：

1. **评分覆盖均匀**：90%以上作品在30天内获得18-22个评分
2. **时间分布合理**：新作品在一周内获得充分关注
3. **用户参与度**：85%以上用户完成20个评分目标
4. **系统自动化**：减少人工干预，系统自动维护评分平衡

该方案充分考虑了滚动提交的特殊性，通过智能算法确保每个作品都能获得公平的评分机会，同时合理分配用户的评分任务，实现整体评分生态的平衡发展。
